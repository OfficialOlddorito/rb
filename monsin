--[[ hello very cool incognito / solara (mostly incognito because solara has most of these functions, just not all) script showcase!! 
pls dont steal source code :( 
also join https://discord.gg/gYhqMRBeZV because yes    
]]
--[[
 math support update because math is kewl
 new update:
 table loop update!!
]]
if getgenv and getgenv().MoreUNC then return end

-- Definitions
local table = table.clone(table) -- Prevent modifications from other scripts
local debug = table.clone(debug) -- ^^^^
local bit32 = table.clone(bit32)
local bit = bit32
local os = table.clone(os)
local math = table.clone(math)
local utf8 = table.clone(utf8)
local string = table.clone(string)
local task = table.clone(task)

local game = game -- game is game
local oldGame = game

local Version = '1.1.6'

local isDragging = false -- rconsole
local dragStartPos = nil -- rconsole
local frameStartPos = nil -- rconsole

local Data = game:GetService("TeleportService"):GetLocalPlayerTeleportData()
local TeleportData
if Data and Data.MOREUNCSCRIPTQUEUE then
 TeleportData = Data.MOREUNCSCRIPTQUEUE
end
if TeleportData then
 local func = loadstring(TeleportData)
 local s, e = pcall(func)
 if not s then task.spawn(error, e) end
end


print = print
warn = warn
error = error
pcall = pcall
printidentity = printidentity
ipairs = ipairs
pairs = pairs
tostring = tostring
tonumber = tonumber
setmetatable = setmetatable
rawget = rawget
rawset = rawset
getmetatable = getmetatable
type = type
version = version

-- Services / Instances
local HttpService = game:GetService('HttpService');
local Log = game:GetService('LogService');

-- Load proprerties (CREDITS TO DEUCES ON DISCORD)
local API_Dump_Url = "https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/roblox/Mini-API-Dump.json"
local API_Dump = game:HttpGet(API_Dump_Url)
local Hidden = {}

for _, API_Class in pairs(HttpService:JSONDecode(API_Dump).Classes) do
    for _, Member in pairs(API_Class.Members) do
        if Member.MemberType == "Property" then
            local PropertyName = Member.Name

            local MemberTags = Member.Tags

            local Special

            if MemberTags then
                Special = table.find(MemberTags, "NotScriptable")
            end
            if Special then
                table.insert(Hidden, PropertyName)
            end
        end
    end
end

local vim = Instance.new("VirtualInputManager");

local DrawingDict = Instance.new("ScreenGui") -- For drawing.new

local ClipboardUI = Instance.new("ScreenGui") -- For setclipboard

local hui = Instance.new("Folder") -- For gethui
hui.Name = '\0'

local ClipboardBox = Instance.new('TextBox', ClipboardUI) -- For setclipboard
ClipboardBox.Position = UDim2.new(100, 0, 100, 0) -- VERY off screen

-- All the following are for rconsole
local Console = Instance.new("ScreenGui")
local ConsoleFrame = Instance.new("Frame")
local Topbar = Instance.new("Frame")
local _CORNER = Instance.new("UICorner")
local ConsoleCorner = Instance.new("UICorner")
local CornerHide = Instance.new("Frame")
local DontModify = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local CornerHide2 = Instance.new("Frame")
local Title = Instance.new("TextLabel")
local UIPadding = Instance.new("UIPadding")
local ConsoleIcon = Instance.new("ImageLabel")
local Holder = Instance.new("ScrollingFrame")
local MessageTemplate = Instance.new("TextLabel")
local InputTemplate = Instance.new("TextBox")
local UIListLayout = Instance.new("UIListLayout")
local HolderPadding = Instance.new("UIPadding")

Console.Name = "Console"
Console.Parent = nil
Console.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

ConsoleFrame.Name = "ConsoleFrame"
ConsoleFrame.Parent = Console
ConsoleFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ConsoleFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
ConsoleFrame.BorderSizePixel = 0
ConsoleFrame.Position = UDim2.new(0.0963890627, 0, 0.220791712, 0)
ConsoleFrame.Size = UDim2.new(0, 888, 0, 577)

Topbar.Name = "Topbar"
Topbar.Parent = ConsoleFrame
Topbar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Topbar.BorderColor3 = Color3.fromRGB(0, 0, 0)
Topbar.BorderSizePixel = 0
Topbar.Position = UDim2.new(0, 0, -0.000463640812, 0)
Topbar.Size = UDim2.new(1, 0, 0, 32)

_CORNER.Name = "_CORNER"
_CORNER.Parent = Topbar

ConsoleCorner.Name = "ConsoleCorner"
ConsoleCorner.Parent = ConsoleFrame

CornerHide.Name = "CornerHide"
CornerHide.Parent = ConsoleFrame
CornerHide.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CornerHide.BorderColor3 = Color3.fromRGB(0, 0, 0)
CornerHide.BorderSizePixel = 0
CornerHide.Position = UDim2.new(0, 0, 0.0280000009, 0)
CornerHide.Size = UDim2.new(1, 0, 0, 12)

DontModify.Name = "DontModify"
DontModify.Parent = ConsoleFrame
DontModify.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
DontModify.BorderColor3 = Color3.fromRGB(0, 0, 0)
DontModify.BorderSizePixel = 0
DontModify.Position = UDim2.new(0.98169291, 0, 0.0278581586, 0)
DontModify.Size = UDim2.new(-0.00675675692, 21, 0.972141862, 0)

UICorner.Parent = DontModify

CornerHide2.Name = "CornerHide2"
CornerHide2.Parent = ConsoleFrame
CornerHide2.AnchorPoint = Vector2.new(1, 0)
CornerHide2.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CornerHide2.BorderColor3 = Color3.fromRGB(0, 0, 0)
CornerHide2.BorderSizePixel = 0
CornerHide2.Position = UDim2.new(1, 0, 0.0450000018, 0)
CornerHide2.Size = UDim2.new(0, 9, 0.955023408, 0)

Title.Name = "Title"
Title.Parent = ConsoleFrame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.0440017432, 0, 0, 0)
Title.Size = UDim2.new(0, 164, 0, 30)
Title.Font = Enum.Font.GothamMedium
Title.Text = "rconsole title"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 17.000
Title.TextXAlignment = Enum.TextXAlignment.Left

UIPadding.Parent = Title
UIPadding.PaddingTop = UDim.new(0, 5)

ConsoleIcon.Name = "ConsoleIcon"
ConsoleIcon.Parent = ConsoleFrame
ConsoleIcon.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ConsoleIcon.BackgroundTransparency = 1.000
ConsoleIcon.BorderColor3 = Color3.fromRGB(0, 0, 0)
ConsoleIcon.BorderSizePixel = 0
ConsoleIcon.Position = UDim2.new(0.00979213417, 0, 0.000874322082, 0)
ConsoleIcon.Size = UDim2.new(0, 31, 0, 31)
ConsoleIcon.Image = "http://www.roblox.com/asset/?id=11843683545"

Holder.Name = "Holder"
Holder.Parent = ConsoleFrame
Holder.Active = true
Holder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Holder.BackgroundTransparency = 1.000
Holder.BorderColor3 = Color3.fromRGB(0, 0, 0)
Holder.BorderSizePixel = 0
Holder.Position = UDim2.new(0, 0, 0.054600548, 0)
Holder.Size = UDim2.new(1, 0, 0.945399463, 0)
Holder.ScrollBarThickness = 8
Holder.CanvasSize = UDim2.new(0,0,0,0)
Holder.AutomaticCanvasSize = Enum.AutomaticSize.XY

MessageTemplate.Name = "MessageTemplate"
MessageTemplate.Parent = Holder
MessageTemplate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MessageTemplate.BackgroundTransparency = 1.000
MessageTemplate.BorderColor3 = Color3.fromRGB(0, 0, 0)
MessageTemplate.BorderSizePixel = 0
MessageTemplate.Size = UDim2.new(0.9745, 0, 0.030000001, 0)
MessageTemplate.Visible = false
MessageTemplate.Font = Enum.Font.RobotoMono
MessageTemplate.Text = "TEMPLATE"
MessageTemplate.TextColor3 = Color3.fromRGB(255, 255, 255)
MessageTemplate.TextSize = 20.000
MessageTemplate.TextXAlignment = Enum.TextXAlignment.Left
MessageTemplate.TextYAlignment = Enum.TextYAlignment.Top
MessageTemplate.RichText = true

UIListLayout.Parent = Holder
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 4)

HolderPadding.Name = "HolderPadding"
HolderPadding.Parent = Holder
HolderPadding.PaddingLeft = UDim.new(0, 15)
HolderPadding.PaddingTop = UDim.new(0, 15)

InputTemplate.Name = "InputTemplate"
InputTemplate.Parent = nil
InputTemplate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
InputTemplate.BackgroundTransparency = 1.000
InputTemplate.BorderColor3 = Color3.fromRGB(0, 0, 0)
InputTemplate.BorderSizePixel = 0
InputTemplate.Size = UDim2.new(0.9745, 0, 0.030000001, 0)
InputTemplate.Visible = false
InputTemplate.RichText = true
InputTemplate.Font = Enum.Font.RobotoMono
InputTemplate.Text = ""
InputTemplate.PlaceholderText = ''
InputTemplate.TextColor3 = Color3.fromRGB(255, 255, 255)
InputTemplate.TextSize = 20.000
InputTemplate.TextXAlignment = Enum.TextXAlignment.Left
InputTemplate.TextYAlignment = Enum.TextYAlignment.Top

-- Variables
local Identity = -1
local active = true
-- Others
local oldLoader = loadstring
-- Empty Tables
local clonerefs = {}
local protecteduis = {}
local gc = {}
local Instances = {} -- for nil instances
local funcs = {} -- main table
local names = {} -- protected gui names
local cache = {} -- for cached instances
local Drawings = {} -- for cleardrawcache
-- Non empty tables
local colors = {
	BLACK = Color3.fromRGB(50, 50, 50),
	BLUE = Color3.fromRGB(0, 0, 204),
	GREEN = Color3.fromRGB(0, 255, 0),
	CYAN = Color3.fromRGB(0, 255, 255),
	RED = Color3.fromHex('#5A0101'),
	MAGENTA = Color3.fromRGB(255, 0, 255),
	BROWN = Color3.fromRGB(165, 42, 42),
	LIGHT_GRAY = Color3.fromRGB(211, 211, 211),
	DARK_GRAY = Color3.fromRGB(169, 169, 169),
	LIGHT_BLUE = Color3.fromRGB(173, 216, 230),
	LIGHT_GREEN = Color3.fromRGB(144, 238, 144),
	LIGHT_CYAN = Color3.fromRGB(224, 255, 255),
	LIGHT_RED = Color3.fromRGB(255, 204, 203),
	LIGHT_MAGENTA = Color3.fromRGB(255, 182, 193),
	YELLOW = Color3.fromRGB(255, 255, 0),
	WHITE = Color3.fromRGB(255, 255, 255),
	ORANGE = Color3.fromRGB(255, 186, 12)
}
local patterns = {
    { pattern = '(%w+)%s*%+=%s*(%w+)', format = "%s = %s + %s" },
    { pattern = '(%w+)%s*%-=%s*(%w+)', format = "%s = %s - %s" },
    { pattern = '(%w+)%s*%*=%s*(%w+)', format = "%s = %s * %s" },
    { pattern = '(%w+)%s*/=%s*(%w+)', format = "%s = %s / %s" }
}
local patterns2 = {
 { pattern = 'for%s+(%w+)%s*,%s*(%w+)%s*in%s*(%w+)%s*do', format = "for %s, %s in pairs(%s) do" }
}
local renv = {
    print, warn, error, assert, collectgarbage, load, require, select, tonumber, tostring, type, xpcall, pairs, next, ipairs,
    newproxy, rawequal, rawget, rawset, rawlen, setmetatable, PluginManager,
    coroutine.create, coroutine.resume, coroutine.running, coroutine.status, coroutine.wrap, coroutine.yield,
    bit32.arshift, bit32.band, bit32.bnot, bit32.bor, bit32.btest, bit32.extract, bit32.lshift, bit32.replace, bit32.rshift, bit32.xor,
    math.abs, math.acos, math.asin, math.atan, math.atan2, math.ceil, math.cos, math.cosh, math.deg, math.exp, math.floor, math.fmod, math.frexp, math.ldexp, math.log, math.log10, math.max, math.min, math.modf, math.pow, math.rad, math.random, math.randomseed, math.sin, math.sinh, math.sqrt, math.tan, math.tanh,
    string.byte, string.char, string.find, string.format, string.gmatch, string.gsub, string.len, string.lower, string.match, string.pack, string.packsize, string.rep, string.reverse, string.sub, string.unpack, string.upper,
    table.concat, table.insert, table.pack, table.remove, table.sort, table.unpack,
    utf8.char, utf8.charpattern, utf8.codepoint, utf8.codes, utf8.len, utf8.nfdnormalize, utf8.nfcnormalize,
    os.clock, os.date, os.difftime, os.time,
    delay, elapsedTime, require, spawn, tick, time, typeof, UserSettings, version, wait,
    task.defer, task.delay, task.spawn, task.wait,
    debug.traceback, debug.profilebegin, debug.profileend
}
local keys={[0x08]=Enum.KeyCode.Backspace,[0x09]=Enum.KeyCode.Tab,[0x0C]=Enum.KeyCode.Clear,[0x0D]=Enum.KeyCode.Return,[0x10]=Enum.KeyCode.LeftShift,[0x11]=Enum.KeyCode.LeftControl,[0x12]=Enum.KeyCode.LeftAlt,[0x13]=Enum.KeyCode.Pause,[0x14]=Enum.KeyCode.CapsLock,[0x1B]=Enum.KeyCode.Escape,[0x20]=Enum.KeyCode.Space,[0x21]=Enum.KeyCode.PageUp,[0x22]=Enum.KeyCode.PageDown,[0x23]=Enum.KeyCode.End,[0x24]=Enum.KeyCode.Home,[0x2D]=Enum.KeyCode.Insert,[0x2E]=Enum.KeyCode.Delete,[0x30]=Enum.KeyCode.Zero,[0x31]=Enum.KeyCode.One,[0x32]=Enum.KeyCode.Two,[0x33]=Enum.KeyCode.Three,[0x34]=Enum.KeyCode.Four,[0x35]=Enum.KeyCode.Five,[0x36]=Enum.KeyCode.Six,[0x37]=Enum.KeyCode.Seven,[0x38]=Enum.KeyCode.Eight,[0x39]=Enum.KeyCode.Nine,[0x41]=Enum.KeyCode.A,[0x42]=Enum.KeyCode.B,[0x43]=Enum.KeyCode.C,[0x44]=Enum.KeyCode.D,[0x45]=Enum.KeyCode.E,[0x46]=Enum.KeyCode.F,[0x47]=Enum.KeyCode.G,[0x48]=Enum.KeyCode.H,[0x49]=Enum.KeyCode.I,[0x4A]=Enum.KeyCode.J,[0x4B]=Enum.KeyCode.K,[0x4C]=Enum.KeyCode.L,[0x4D]=Enum.KeyCode.M,[0x4E]=Enum.KeyCode.N,[0x4F]=Enum.KeyCode.O,[0x50]=Enum.KeyCode.P,[0x51]=Enum.KeyCode.Q,[0x52]=Enum.KeyCode.R,[0x53]=Enum.KeyCode.S,[0x54]=Enum.KeyCode.T,[0x55]=Enum.KeyCode.U,[0x56]=Enum.KeyCode.V,[0x57]=Enum.KeyCode.W,[0x58]=Enum.KeyCode.X,[0x59]=Enum.KeyCode.Y,[0x5A]=Enum.KeyCode.Z,[0x5D]=Enum.KeyCode.Menu,[0x60]=Enum.KeyCode.KeypadZero,[0x61]=Enum.KeyCode.KeypadOne,[0x62]=Enum.KeyCode.KeypadTwo,[0x63]=Enum.KeyCode.KeypadThree,[0x64]=Enum.KeyCode.KeypadFour,[0x65]=Enum.KeyCode.KeypadFive,[0x66]=Enum.KeyCode.KeypadSix,[0x67]=Enum.KeyCode.KeypadSeven,[0x68]=Enum.KeyCode.KeypadEight,[0x69]=Enum.KeyCode.KeypadNine,[0x6A]=Enum.KeyCode.KeypadMultiply,[0x6B]=Enum.KeyCode.KeypadPlus,[0x6D]=Enum.KeyCode.KeypadMinus,[0x6E]=Enum.KeyCode.KeypadPeriod,[0x6F]=Enum.KeyCode.KeypadDivide,[0x70]=Enum.KeyCode.F1,[0x71]=Enum.KeyCode.F2,[0x72]=Enum.KeyCode.F3,[0x73]=Enum.KeyCode.F4,[0x74]=Enum.KeyCode.F5,[0x75]=Enum.KeyCode.F6,[0x76]=Enum.KeyCode.F7,[0x77]=Enum.KeyCode.F8,[0x78]=Enum.KeyCode.F9,[0x79]=Enum.KeyCode.F10,[0x7A]=Enum.KeyCode.F11,[0x7B]=Enum.KeyCode.F12,[0x90]=Enum.KeyCode.NumLock,[0x91]=Enum.KeyCode.ScrollLock,[0xBA]=Enum.KeyCode.Semicolon,[0xBB]=Enum.KeyCode.Equals,[0xBC]=Enum.KeyCode.Comma,[0xBD]=Enum.KeyCode.Minus,[0xBE]=Enum.KeyCode.Period,[0xBF]=Enum.KeyCode.Slash,[0xC0]=Enum.KeyCode.Backquote,[0xDB]=Enum.KeyCode.LeftBracket,[0xDD]=Enum.KeyCode.RightBracket,[0xDE]=Enum.KeyCode.Quote} -- for keypress
local Fonts = { -- Drawing.Fonts
 [0] = Enum.Font.Arial,
 [1] = Enum.Font.BuilderSans,
 [2] = Enum.Font.Gotham,
 [3] = Enum.Font.RobotoMono
}
-- rconsole
local MessageColor = colors['WHITE']
local ConsoleClone = nil
-- functions
local function Descendants(tbl)
    local descendants = {}
    
    local function process_table(subtbl, prefix)
        for k, v in pairs(subtbl) do
            local index = prefix and (prefix .. "." .. tostring(k)) or tostring(k)
            descendants[index] = v
            if type(v) == 'table' then
                process_table(v, index)
            else
                descendants[index] = v
            end
        end
    end

    if type(tbl) ~= 'table' then
        descendants[tostring(1)] = tbl
    else
        process_table(tbl, nil)
    end
    
    return descendants
end

local function rawlength(tbl)
 local a = 0
 for i, v in pairs(tbl) do
  a = a + 1
 end
 return a
end

local function ToPairsLoop(code)
    for _, p in ipairs(patterns2) do
        code = code:gsub(p.pattern, function(var1, var2, tbl)
            return p.format:format(var1, var2, tbl)
        end)
    end
    return code
end

local function SafeOverride(a, b, c) --[[ Index, Data, Should override ]]
    if getgenv()[a] and not c then return 1 end
    getgenv()[a] = b

    return 2
end

local function toluau(code)
    for _, p in ipairs(patterns) do
        code = code:gsub(p.pattern, function(var, value)
            return p.format:format(var, var, value)
        end)
    end
    code = ToPairsLoop(code)
    return code
end

local function handleInput(input, Object)
    if isDragging then
        local delta = input.Position - dragStartPos
        Object.Position = UDim2.new(
            frameStartPos.X.Scale, 
            frameStartPos.X.Offset + delta.X, 
            frameStartPos.Y.Scale, 
            frameStartPos.Y.Offset + delta.Y
        )
    end
end

local function startDrag(input, Object)
    isDragging = true
    dragStartPos = input.Position
    frameStartPos = Object.Position
    input.UserInputState = Enum.UserInputState.Begin
end

local function stopDrag(input)
    isDragging = false
    input.UserInputState = Enum.UserInputState.End
end

-- Main Functions
function QueueGetIdentity()
  printidentity()
  task.wait(.1)
  local messages = Log:GetLogHistory()
  local message;
  if not messages[#messages].message:match("Current identity is") then
   for i = #messages, 1, -1 do
    if messages[i].message:match("Current identity is %d") then
     message = messages[i].message
     break
    end
   end
  else
   message = messages[#messages].message:match('Current identity is %d'):gsub("Current identity is ", '')
  end
  Identity = tonumber(message)
end
local Queue = {}
Queue.__index = Queue
function Queue.new()
    local self = setmetatable({}, Queue)
    self.elements = {}
    return self
end

function Queue:Queue(element)
    table.insert(self.elements, element)
end

function Queue:Update()
    if #self.elements == 0 then
        return nil
    end
    return table.remove(self.elements, 1)
end

function Queue:IsEmpty()
    return #self.elements == 0
end
function Queue:Current()
    return self.elements
end

-- Events
game.DescendantRemoving:Connect(function(des)
 table.insert(Instances, des)
 cache[des] = 'REMOVE'
end)
game.DescendantAdded:Connect(function(des)
 cache[des] = true
end)
game:GetService("UserInputService").WindowFocused:Connect(function()
 active = true
end)

game:GetService("UserInputService").WindowFocusReleased:Connect(function()
 active = false
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if not input then return end
    if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement and ConsoleClone then
        handleInput(input, ConsoleClone.ConsoleFrame)
    end
end)

game:GetService("UserInputService").InputEnded:Connect(function(input)
    if not input then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        stopDrag(input)
    end
end)
-- Libraries
funcs.base64 = {}
funcs.crypt = {hex={},url={}}
funcs.syn = {}
funcs.syn_backup = {}
funcs.http = {}
funcs.Drawing = {}
funcs.cache = {}
funcs.string = string
funcs.debug = debug
funcs.debug.getinfo = function(t)
    local CurrentLine = tonumber(debug.info(t, 'l'))
    local Source = debug.info(t, 's')
    local name = debug.info(t, 'n')
    local numparams, isvrg = debug.info(t, 'a')
    if #name == 0 then name = nil end
    local a, b = debug.info(t, 'a')
    return {
     ['currentline'] = CurrentLine,
     ['source'] = Source,
     ['name'] = tostring(name),
     ['numparams'] = tonumber(numparams),
     ['is_vararg'] = isvrg and 1 or 0,
     ['short_src'] = tostring(Source:sub(1, 60)),
     ['what'] = Source == '[C]' and 'C' or 'Lua',
     ['func'] = t,
     ['nups'] = 0 -- i CANNOT make an upvalue thingy
     }
end

funcs.Drawing.Fonts = {
  ['UI'] = 0,
  ['System'] = 1,
  ['Plex'] = 2,
  ['Monospace'] = 3
}


local ClipboardQueue = Queue.new()
local ConsoleQueue = Queue.new()
local getgenv = getgenv or getfenv(2)
getgenv().getgenv = getgenv

-- [[ Functions ]]

--[[funcs.cloneref = function(a)
    if not clonerefs[a] then clonerefs[a] = {} end
    local Clone = {}

    local mt = {__type='Instance'} -- idk if this works ;(

    mt.__tostring = function()
        return a.Name
    end

    mt.__index = function(_, key)
        local thing = funcs.debug.getmetatable(a)[key]
        if type(thing) == 'function' then
            return function(...)
                return thing(a, ...)
            end
        else
            return thing
        end
    end
    mt.__newindex = function(_, key, value)
     a[key] = value
    end
    mt.__metatable = getmetatable(a)
    mt.__len = function(_)
     return error('attempt to get length of a userdata value')
    end

    setmetatable(Clone, mt)

    table.insert(clonerefs[a], Clone)

    return Clone
end
TEMPORARY REMOVED UNTIL WE FIND A FIX
]]

-- Thanks to xAPI for the following:

local Sandbox = loadstring(game:HttpGet("https://pastebin.com/raw/a0cuADU4"))()
funcs.string.dump = loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Function-Dumper-14820"))()
funcs.dumpstring = funcs.string.dump

-- // The rest is made by me.

funcs.compareinstances = function(a, b)
 if not clonerefs[a] then
  return a == b
 else
  if table.find(clonerefs[a], b) then return true end
 end
 return false
end

funcs.clonefunction = function(a)
 assert(type(a)=='function', 'Invalid parameter 1 to \'clonefunction\', function expected got ' .. typeof(a))

 return function(...)
  local Copy = Sandbox(a, {}, {}, {}, 0, {...})
  return Copy.return_value
 end
end

funcs.cache.iscached = function(thing)
 return cache[thing] ~= 'REMOVE' and thing:IsDescendantOf(game) or false -- If it's cache isnt 'REMOVE' and its a des of game (Usually always true) or if its cache is 'REMOVE' then its false.
end
funcs.cache.invalidate = function(thing)
 cache[thing] = 'REMOVE'
 thing.Parent = nil
end
funcs.cache.replace = function(a, b)
 if cache[a] then
  cache[a] = b
 end
 local n, p = a.Name, a.Parent -- name, parent
 b.Parent = p
 b.Name = n
 a.Parent = nil
end
funcs.deepclone = function(a)
 local Result = {}
 for i, v in pairs(a) do
  if type(v) == 'table' then
    Result[i] = funcs.deepclone(v)
  end
  Result[i] = v
 end
 return Result
end
--[[ The base64 functions were made by https://scriptblox.com/u/yofriendfromschool1 , Credits to him.]]
funcs.base64.encode = function(data)
    local letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    return ((data:gsub('.', function(x) 
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return letters:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end
funcs.base64.decode = function(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    data = string.gsub(data, '[^'..b..'=]', '')
    return (data:gsub('.', function(x)
        if x == '=' then return '' end
        local r, f = '', (b:find(x) - 1)
        for i = 6, 1, -1 do
            r = r .. (f % 2^i - f % 2^(i - 1) > 0 and '1' or '0')
        end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if #x ~= 8 then return '' end
        local c = 0
        for i = 1, 8 do
            c = c + (x:sub(i, i) == '1' and 2^(8 - i) or 0)
        end
        return string.char(c)
    end))
end

funcs.loadstring = function(code)
 local s1, val1 = pcall(function()
  return loadstring('local v1=15;v1+=1;return v1')()
 end)
 local s2, val2 = pcall(function()
  return loadstring('local v1={"a"};for i, v in v1 do return v end')()
 end)
 if val1 ~= 16 and val2 ~= 'a' then
  return oldLoader(toluau(code))
 else
  return oldLoader(code)
 end
end
funcs.getgenv = getgenv
funcs.crypt.base64 = funcs.base64
funcs.crypt.base64encode = funcs.base64.encode
funcs.crypt.base64decode = funcs.base64.decode
funcs.crypt.base64_encode = funcs.base64.encode
funcs.crypt.base64_decode = funcs.base64.decode
funcs.base64_encode = funcs.base64.encode
funcs.base64_decode = funcs.base64.decode

funcs.crypt.hex.encode = function(txt)
 txt = tostring(txt)
 local hex = ''
 for i = 1, #txt do
    hex = hex .. string.format("%02x", string.byte(txt, i))
 end
 return hex
end
funcs.crypt.hex.decode = function(hex)
    hex = tostring(hex)
    local text = ""
    for i = 1, #hex, 2 do
        local byte_str = string.sub(hex, i, i+1)
        local byte = tonumber(byte_str, 16)
        text = text .. string.char(byte)
    end
    return text
end
funcs.crypt.url.encode = function(a)
 return game:GetService("HttpService"):UrlEncode(a)
end
funcs.crypt.url.decode = function(a)
    a = tostring(a)
    a = string.gsub(a, "+", " ")
    a = string.gsub(a, "%%(%x%x)", function(hex)
        return string.char(tonumber(hex, 16))
    end)
    a = string.gsub(a, "\r\n", "\n")
    return a
end
funcs.crypt.generatekey = function(optionalSize)
 local key = ''
 local a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
 for i = 1, optionalSize or 32 do local n = math.random(1, #a) key = key .. a:sub(n, n) end
 return funcs.base64.encode(key)
end
funcs.crypt.generatebytes = function(size)
 if type(size) ~= 'number' then return error('missing arguement #1 to \'generatebytes\' (number expected)') end
 return funcs.crypt.generatekey(size)
end
funcs.crypt.encrypt = function(a, b)
 local result = {}
 a = tostring(a) b = tostring(b)
 for i = 1, #a do
    local byte = string.byte(a, i)
    local keyByte = string.byte(b, (i - 1) % #b + 1)
    table.insert(result, string.char(bit32.bxor(byte, keyByte)))
 end
 return table.concat(result)
end
funcs.crypt.decrypt = funcs.crypt.encrypt
funcs.crypt.random = function(len)
 return funcs.crypt.generatekey(len)
end

funcs.isrbxactive = function()
 return active
end
funcs.isgameactive = funcs.isrbxactive
funcs.gethui = function()
 local s, H = pcall(function()
  return game:GetService("CoreGui").RobloxGui
 end)
 if H then
  if not hui.Parent then
    hui.Parent = H.Parent
  end
  return hui
 else
  if not hui.Parent then
    hui.Parent = game:GetService("Players").LocalPlayer.PlayerGui
  end
 end
 return hui
end
if getgenv().getrenv and #getgenv().getrenv() == 0 or not getgenv().getrenv then
 getgenv().getrenv = nil
 getgenv().getrenv = function() -- Override incognito's getrenv
  return renv -- couldn't think of a better way to implement it
 end
end
funcs.setclipboard = function(data)
    repeat task.wait() until ClipboardQueue:Current()[1] == data or ClipboardQueue:IsEmpty()
    ClipboardQueue:Queue(data)
    local old = game:GetService("UserInputService"):GetFocusedTextBox()
    local copy = ClipboardQueue:Current()[1]
    ClipboardBox:CaptureFocus()
    ClipboardBox.Text = copy
    
    local KeyCode = Enum.KeyCode
    local Keys = {KeyCode.RightControl, KeyCode.A}
    local Keys2 = {KeyCode.RightControl, KeyCode.C, KeyCode.V}
    
    for _, v in ipairs(Keys) do
        vim:SendKeyEvent(true, v, false, game)
        task.wait()
    end
    for _, v in ipairs(Keys) do
        vim:SendKeyEvent(false, v, false, game)
        task.wait()
    end
    for _, v in ipairs(Keys2) do
        vim:SendKeyEvent(true, v, false, game)
        task.wait()
    end
    for _, v in ipairs(Keys2) do
        vim:SendKeyEvent(false, v, false, game)
        task.wait()
    end
    ClipboardBox.Text = ''
    if old then old:CaptureFocus() end
    task.wait(.18)
    ClipboardQueue:Update()
end
funcs.syn.write_clipboard = funcs.setclipboard
funcs.toclipboard = funcs.setclipboard
funcs.writeclipboard = funcs.setclipboard
funcs.setrbxclipboard = funcs.setclipboard

funcs.isrenderobj = function(thing)
 return Drawings[thing] ~= nil
end
funcs.getrenderproperty = function(thing, prop)
 return thing[prop]
end
funcs.setrenderproperty = function(thing, prop, val)
 local success, err = pcall(function()
  thing[prop] = val
 end)
 if not success and err then warn(err) end
end

funcs.syn.protect_gui = function(gui)
 names[gui] = {name=gui.Name,parent=gui.Parent}
 protecteduis[gui] = gui
 gui.Name = funcs.crypt.random(64) -- 64 byte string, removed hashing cuz its useless lmao
 gui.Parent = gethui()
end
funcs.syn.unprotect_gui = function(gui)
 if names[gui] then gui.Name = names[gui].name gui.Parent = names[gui].parent end protecteduis[gui] = nil
end
funcs.syn.protectgui = funcs.syn.protect_gui
funcs.syn.unprotectgui = funcs.syn.unprotect_gui
funcs.syn.secure_call = function(func) -- Does not do a secure call, just pcalls it.
 return pcall(func)
end


funcs.isreadonly = function(tbl)
 if type(tbl) ~= 'table' then return false end
 return table.isfrozen(tbl)
end
funcs.setreadonly = function(tbl, cond)
 if cond then
  table.freeze(tbl)
 else
  return funcs.deepclone(tbl)
 end
end
funcs.httpget = function(url)
 return game:HttpGet(url)
end
funcs.httppost = function(url, body, contenttype)
 return game:HttpPostAsync(url, body, contenttype)
end
funcs.request = function(args)
 local Body = nil
 local Timeout = 0
 local function callback(success, body)
  Body = body
  Body['Success'] = success
 end
 HttpService:RequestInternal(args):Start(callback)
 while not Body and Timeout < 10 do
  task.wait(.1)
  Timeout = Timeout + .1
 end
 return Body
end
funcs.mouse1click = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, true, game, false)
 task.wait()
 vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end
funcs.mouse2click = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, true, game, false)
 task.wait()
 vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end
funcs.mouse1press = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, true, game, false)
end
funcs.mouse1release = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end
funcs.mouse2press = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, true, game, false)
end
funcs.mouse2release = function(x, y)
 x = x or 0
 y = y or 0
 vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end
funcs.mousescroll = function(x, y, a)
 x = x or 0
 y = y or 0
 a = a and true or false
 vim:SendMouseWheelEvent(x, y, a, game)
end
funcs.keyclick = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(true, keys[key], false, game)
 task.wait()
 vim:SendKeyEvent(false, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(true, key, false, game)
  task.wait()
  vim:SendKeyEvent(false, key, false, game)
 end
end
funcs.keypress = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(true, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(true, key, false, game)
 end
end
funcs.keyrelease = function(key)
 if typeof(key) == 'number' then
 if not keys[key] then return error("Key "..tostring(key) .. ' not found!') end
 vim:SendKeyEvent(false, keys[key], false, game)
 elseif typeof(Key) == 'EnumItem' then
  vim:SendKeyEvent(false, key, false, game)
 end
end
funcs.mousemoverel = function(relx, rely)
 local Pos = workspace.CurrentCamera.ViewportSize
 relx = relx or 0
 rely = rely or 0
 local x = Pos.X * relx
 local y = Pos.Y * rely
 vim:SendMouseMoveEvent(x, y, game)
end
funcs.mousemoveabs = function(x, y)
 x = x or 0 y = y or 0
 vim:SendMouseMoveEvent(x, y, game)
end

funcs.newcclosure = function(f)
 local a = coroutine.wrap(function(...)
  local b = {coroutine.yield()}
  while true do
   b = {coroutine.yield(f(table.unpack(b)))}
  end
 end)
 a()
 return a
end -- Credits to myworld AND EMPER for this
funcs.iscclosure = function(fnc) return debug.info(fnc, 's') == '[C]' end
funcs.islclosure = function(func) return not funcs.iscclosure(func) end
funcs.isexecutorclosure = function(fnc)
    local found = false
    for i, v in pairs(getgenv()) do
     if v == fnc then return true end
    end
    for i = 1, math.huge do
        local s, env = pcall(getfenv, i)
        if not s or found then break end
        if type(env) == "table" then
            for _, v in pairs(env) do
                if v == fnc then
                    found = true
                    break
                end
            end
        end
        if found then break end
    end

    return found
end
funcs.newlclosure = function(fnc)
 return function(...) return fnc(...) end
end
funcs.clonefunction = funcs.newlclosure
funcs.is_l_closure = funcs.islclosure
funcs.is_executor_closure = funcs.isexecutorclosure
funcs.isourclosure = funcs.isexecutorclosure
funcs.isexecclosure = funcs.isexecutorclosure
funcs.checkclosure = funcs.isourclosure

--[[ File system is something i do not know how to implement in roblox lua.
UPDATE AT 18/5/2024:
I figured out i can use temp file system with tables.
]]
local files = {}

local function startswith(a, b)
 return a:sub(1, #b) == b
end
local function endswith(hello, lo) 
    return hello:sub(#hello - #lo + 1, #hello) == lo
end

funcs.writefile = function(path, content)
 local Path = path:split('/')
 local CurrentPath = {}
 for i = 1, #Path do
  local a = Path[i]
  CurrentPath[i] = a
  if not files[a] and i ~= #Path then
   files[table.concat(CurrentPath, '/')] = {}
   files[table.concat(CurrentPath, '/') .. '/'] = files[table.concat(CurrentPath, '/')]
  elseif i == #Path then
   files[table.concat(CurrentPath, '/')] = tostring(content)
  end
 end
end
funcs.makefolder = function(path)
 files[path] = {}
 files[path .. '/'] = files[path]
end
funcs.isfolder = function(path)
 return type(files[path]) == 'table'
end
funcs.isfile = function(path)
 return type(files[path]) == 'string'
end
funcs.readfile = function(path)
 return files[path]
end
funcs.appendfile = function(path, text2)
 funcs.writefile(path, funcs.readfile(path) .. text2)
end
funcs.loadfile = function(path)
 local content = funcs.readfile(path)
 if not content then error('File \'' .. tostring(path) .. '\' does not exist.') return '' end
 local s, func = pcall(function()
  return loadstring(content)
 end)
 return func, not s and func or nil
end
funcs.delfolder = function(path)
 local f = files[path]
 if type(f) == 'table' then files[path] = nil end
end
funcs.delfile = function(path)
 local f = files[path]
 if type(f) == 'string' then files[path] = nil end
end
funcs.listfiles = function(path)
    if not path or path == '' then
     local Files = {}
     for i, v in pairs(files) do
      if #i:split('/') == 1 then table.insert(Files, i) end
     end
     return Files
    end
    if type(files[path]) ~= 'table' then return error(path .. ' is not a folder.') end
    local Files = {}
    for i, v in pairs(files) do
      if startswith(i, path .. '/') and not endswith(i, '/') and i ~= path and #i:split('/') == (#path:split('/') + 1) then table.insert(Files, i) end
    end
    return Files
end

funcs.http.request = funcs.request
funcs.syn.crypt = funcs.crypt
funcs.syn.crypto = funcs.crypt
funcs.syn_backup = funcs.syn


funcs.getexecutorname = function()
 return 'MoreUNC', Version
end
funcs.identifyexecutor = funcs.getexecutorname
funcs.http_request = getgenv().request or funcs.request
funcs.getscripts = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("LocalScript") or v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.get_scripts = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("LocalScript") or v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.getmodules = function()
 local a = {};for i, v in pairs(game:GetDescendants()) do if v:IsA("ModuleScript") then table.insert(a, v) end end return a
end
funcs.getloadedmodules = funcs.getmodules
funcs.make_readonly = funcs.setreadonly
funcs.makereadonly = funcs.setreadonly
funcs.base64encode = funcs.crypt.base64encode
funcs.base64decode = funcs.crypt.base64decode
funcs.clonefunc = funcs.clonefunction
funcs.setsimulationradius = function(Distance, MaxDistance)
 local LocalPlayer = game:GetService("Players").LocalPlayer
 assert(type(Distance)=='number','Invalid arguement #1 to \'setsimulationradius\', Number expected got ' .. type(Distance))
 LocalPlayer.SimulationRadius = type(Distance) == 'number' and Distance or LocalPlayer.SimulationRadius
 if MaxDistance then
  assert(type(MaxDistance)=='number','Invalid arguement #2 to \'setsimulationradius\', Number expected got ' .. type(MaxDistance))
  LocalPlayer.MaxSimulationDistance = MaxDistance
 end
end
funcs.getinstances = function()
 return game:GetDescendants()
end
funcs.getnilinstances = function()
 return Instances
end
funcs.iswriteable = function(tbl)
 return not table.isfrozen(tbl)
end
funcs.makewriteable = function(tbl)
 return funcs.setreadonly(tbl, false)
end
funcs.isscriptable = function(self, prop)
 return table.find(Hidden, prop) == nil
end
funcs.getrunningscripts = function()
 local scripts = {}
 for _, v in pairs(funcs.getinstances()) do
  if v:IsA("LocalScript") and v.Enabled then table.insert(scripts, v) end
 end
 return scripts
end
funcs.fireproximityprompt = function(p)
 local Hold, Distance, Enabled, Thing, CFrame1= p.HoldDuration, p.MaxActivationDistance, p.Enabled, p.RequiresLineOfSight, nil
 -- Make it activatable from anywhere
 p.MaxActivationDistance = math.huge
 -- Make it take 0 seconds to activate
 p.HoldDuration = 0
 -- Make it enabled (so you can activate it)
 p.Enabled = true
 -- Disable RequiresLineOfSight
 p.RequiresLineOfSight = false
 -- Show the thingy
 local function get()
  local classes = {'BasePart', 'Part', 'MeshPart'}
  for _, v in pairs(classes) do
   if p:FindFirstAncestorOfClass(v) then
    return p:FindFirstAncestorOfClass(v)
   end
  end
 end
 local a = get()
 if not a then
  local parent = p.Parent
  p.Parent = Instance.new("Part", workspace)
  a = p.Parent
 end
 CFrame1 = a.CFrame
 a.CFrame = game:GetService("Players").LocalPlayer.Character.Head.CFrame + game:GetService("Players").LocalPlayer.Character.Head.CFrame.LookVector * 2
 task.wait()
 p:InputHoldBegin()
 task.wait()
 p:InputHoldEnd()
 p.HoldDuration = Hold
 p.MaxActivationDistance = Distance
 p.Enabled = Enabled
 p.RequiresLineOfSight = Thing
 a.CFrame = CFrame1
 p.Parent = parent or p.Parent
end
funcs.firetouchinterest = function(toTouch, TouchWith, on)
 if on == 0 then return end
 if toTouch.ClassName == 'TouchTransmitter' then
   local function get()
    local classes = {'BasePart', 'Part', 'MeshPart'}
    for _, v in pairs(classes) do
    if toTouch:FindFirstAncestorOfClass(v) then
     return toTouch:FindFirstAncestorOfClass(v)
    end
   end
  end
  toTouch = get()
 end
 local cf = toTouch.CFrame
 local anc = toTouch.CanCollide
 toTouch.CanCollide = false
 toTouch.CFrame = TouchWith.CFrame
 task.wait()
 toTouch.CFrame = cf
 toTouch.CanCollide = anc
end -- i admit its kinda bad dont fucking attack me

-- SHA256 Hashing
local function str2hexa(a)return string.gsub(a,".",function(b)return string.format("%02x",string.byte(b))end)end;local function num2s(c,d)local a=""for e=1,d do local f=c%256;a=string.char(f)..a;c=(c-f)/256 end;return a end;local function s232num(a,e)local d=0;for g=e,e+3 do d=d*256+string.byte(a,g)end;return d end;local function preproc(h,i)local j=64-(i+9)%64;i=num2s(8*i,8)h=h.."\128"..string.rep("\0",j)..i;assert(#h%64==0)return h end;local function k(h,e,l)local m={}local n={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}for g=1,16 do m[g]=s232num(h,e+(g-1)*4)end;for g=17,64 do local o=m[g-15]local p=bit.bxor(bit.rrotate(o,7),bit.rrotate(o,18),bit.rshift(o,3))o=m[g-2]local q=bit.bxor(bit.rrotate(o,17),bit.rrotate(o,19),bit.rshift(o,10))m[g]=(m[g-16]+p+m[g-7]+q)%2^32 end;local r,s,b,t,u,v,w,x=l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8]for e=1,64 do local p=bit.bxor(bit.rrotate(r,2),bit.rrotate(r,13),bit.rrotate(r,22))local y=bit.bxor(bit.band(r,s),bit.band(r,b),bit.band(s,b))local z=(p+y)%2^32;local q=bit.bxor(bit.rrotate(u,6),bit.rrotate(u,11),bit.rrotate(u,25))local A=bit.bxor(bit.band(u,v),bit.band(bit.bnot(u),w))local B=(x+q+A+n[e]+m[e])%2^32;x=w;w=v;v=u;u=(t+B)%2^32;t=b;b=s;s=r;r=(B+z)%2^32 end;l[1]=(l[1]+r)%2^32;l[2]=(l[2]+s)%2^32;l[3]=(l[3]+b)%2^32;l[4]=(l[4]+t)%2^32;l[5]=(l[5]+u)%2^32;l[6]=(l[6]+v)%2^32;l[7]=(l[7]+w)%2^32;l[8]=(l[8]+x)%2^32 end;funcs.crypt.hash=function(h)h=preproc(h,#h)local l={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19}for e=1,#h,64 do k(h,e,l)end;return str2hexa(num2s(l[1],4)..num2s(l[2],4)..num2s(l[3],4)..num2s(l[4],4)..num2s(l[5],4)..num2s(l[6],4)..num2s(l[7],4)..num2s(l[8],4))end

funcs.Drawing.new = function(Type) -- Drawing.new
    local baseProps = {
     Visible = false,
     Color = Color3.new(0,0,0),
     ClassName = nil
    }
    if Type == 'Line' then
        local a = Instance.new("Frame", Instance.new("ScreenGui", DrawingDict))
        a.Visible = false
        a.Size = UDim2.new(0, 0, 0, 0)
        a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        a.BackgroundTransparency = 1
        a.BorderSizePixel = 0

        local meta = baseProps
        meta.ClassName = Type
        meta.__index = {
            Thickness = 1,
            From = Vector2.new(0, 0),
            To = Vector2.new(0, 0),
            Transparency = 0,
            Remove = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            Destroy = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            updateLine = function(self)
             if not a then return end
             local from = self.From
             local to = self.To
             local distance = (to - from).Magnitude
             local angle = math.deg(math.atan2(to.Y - from.Y, to.X - from.X))

             a.Size = UDim2.new(0, distance, 0, self.Thickness)
             a.Position = UDim2.new(0, from.X, 0, from.Y)
             a.Rotation = angle
            end
        }

        meta.__newindex = function(self, key, value)
            if not self then return end
            if key == 'Thickness' and typeof(value) == 'number' then
                rawset(self, key, value)
                a.Size = UDim2.new(0, (self.To - self.From).Magnitude, 0, value)
            elseif key == 'Visible' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                a.Visible = value
            elseif key == 'Color' and typeof(value) == 'Color3' then
                rawset(self, key, value)
                a.BackgroundColor3 = value
            elseif key == 'Transparency' and typeof(value) == 'number' and value <= 1 then
                rawset(self, key, value)
                a.BackgroundTransparency = 1 - value
            elseif key == 'From' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
                self:updateLine()
            elseif key == 'To' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
                self:updateLine()
            end
        end
        local meta1 = setmetatable({}, meta)
        Drawings[meta1] = meta1
        return meta1
    elseif Type == 'Square' then
        local a = Instance.new("Frame", DrawingDict)
        a.Visible = false
        a.Size = UDim2.new(0, 0, 0, 0)
        a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        a.BackgroundTransparency = 1
        a.BorderSizePixel = 0
        local b = Instance.new("UIStroke", a)
        b.Color = Color3.fromRGB(255, 255, 255)
        b.Enabled = true

        local meta = baseProps
        meta.ClassName = Type
        meta.__index = {
            Size = Vector2.new(0,0),
            Position = Vector2.new(0, 0),
            Remove = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            Destroy = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            updateSquare = function(self)
             if not a then return end
             a.Size = UDim2.new(0, self.Size.X, 0, self.Size.Y)
             a.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
            end
        }

        meta.__newindex = function(self, key, value)
            if not self then return end
            if key == 'Filled' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                b.Enabled = not value
                a.BackgroundTransparency = value and 0 or 1
            elseif key == 'Visible' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                a.Visible = value
            elseif key == 'Color' and typeof(value) == 'Color3' then
                rawset(self, key, value)
                a.BackgroundColor3 = value
                b.Color = value
            elseif key == 'Position' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
                self:updateSquare()
            elseif key == 'Size' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
                self:updateSquare()
            end
        end
        local meta1 = setmetatable({}, meta)
        Drawings[meta1] = meta1
        return meta1
    elseif Type == 'Circle' then
        local a = Instance.new("Frame", Instance.new("ScreenGui", DrawingDict))
        a.Visible = false
        a.Size = UDim2.new(0, 0, 0, 0)
        a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        a.BackgroundTransparency = 1
        a.BorderSizePixel = 0
        local b = Instance.new("UIStroke", a)
        b.Color = Color3.fromRGB(255, 255, 255)
        b.Enabled = false
        b.Thickness = 1
        local c = Instance.new("UICorner", a)
        c.CornerRadius = UDim.new(1, 0)

        local meta = baseProps
        meta.ClassName = Type
        meta.__index = {
            Thickness = 1,
            Filled = false,
            NumSides = 0,
            Radius = 1,
            Position = Vector2.new(0, 0),
            Transparency = 0,
            Remove = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            Destroy = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            updateCircle = function(self)
             if not b or not a then return end
             a.Size = UDim2.new(0, self.Radius, 0, self.Radius)
             a.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
             b.Enabled = not self
             b.Color = self.Color
            end
        }

        meta.__newindex = function(self, key, value)
            if not self then return end
            if key == 'Thickness' and typeof(value) == 'number' then
                rawset(self, key, value)
                b.Thickness = value
            elseif key == 'Visible' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                a.Visible = value
            elseif key == 'Color' and typeof(value) == 'Color3' then
                rawset(self, key, value)
                a.BackgroundColor3 = value
                a.Color = value
            elseif key == 'Transparency' and typeof(value) == 'number' then
                rawset(self, key, value)
                a.BackgroundTransparency = 1 - value
            elseif key == 'Position' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
                self:updateCircle()
            elseif key == 'Radius' and typeof(value) == 'number' then
                rawset(self, key, value)
                self:updateCircle()
            elseif key == 'NumSides' and typeof(value) == 'number' then
                rawset(self, key, value)
            elseif key == 'Filled' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                self:updateCircle()
            end
        end
        local meta1 = setmetatable({}, meta)
        Drawings[meta1] = meta1
        return meta1
    elseif Type == 'Text' then
        local a = Instance.new("TextLabel", DrawingDict)
        a.Visible = false
        a.Size = UDim2.new(0, 0, 0, 0)
        a.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        a.BackgroundTransparency = 1
        a.BorderSizePixel = 0
        a.TextStrokeColor3 = Color3.new(0,0,0)
        a.TextStrokeTransparency = 1

        local meta = baseProps
        meta.ClassName = Type
        meta.__index = {
            Text = '',
            Transparency = 0,
            Size = 0,
            Center = false,
            Outline = false,
            OutlineColor = Color3.new(0,0,0),
            Position = Vector2.new(0,0),
            Font = 3,
            Remove = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            Destroy = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy() 
            end,
            updateText = function(self)
             if not a then return end
             a.TextScaled = true
             a.Size = UDim2.new(0, self.Size * 3, 0, self.Size / 2)
             a.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
             a.Text = self.Text
             a.Font = Fonts[self.Font]
             a.Visible = self.Visible
             a.TextColor3 = self.Color
             a.TextTransparency = 1 - self.Transparency
             a.BorderSizePixel = self.Outline and 1 or 0
             if self.Center then
              a.TextXAlignment = Enum.TextXAlignment.Center
              a.TextYAlignment = Enum.TextYAlignment.Center
             else
              a.TextXAlignment = Enum.TextXAlignment.Left
              a.TextYAlignment = Enum.TextYAlignment.Top
             end
             a.TextStrokeTransparency = self.Outline and 0 or 1
             a.TextStrokeColor3 = self.OutlineColor
            end
        }

        meta.__newindex = function(self, key, value)
            if not self then return end
            if key == 'Text' and typeof(value) == 'string' then
                rawset(self, key, value)
            elseif key == 'Visible' and typeof(value) == 'boolean' then
                rawset(self, key, value)
                a.Visible = value
            elseif key == 'Color' and typeof(value) == 'Color3' then
                rawset(self, key, value)
            elseif key == 'Transparency' and typeof(value) == 'number' then
                rawset(self, key, value)
            elseif key == 'Position' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
            elseif key == 'Size' and typeof(value) == 'number' then
                rawset(self, key, value)
            elseif key == 'Outline' and typeof(value) == 'boolean' then
                rawset(self, key, value)
            elseif key == 'Center' and typeof(value) == 'boolean' then
                rawset(self, key, value)
            elseif key == 'OutlineColor' and typeof(value) == 'Color3' then
                rawset(self, key, value)
            elseif key == 'Font' and typeof(value) == 'number' then
                rawset(self, key, value)
            end
            self:updateText()
        end

        local meta1 = setmetatable({}, meta)
        Drawings[meta1] = meta1
        return meta1
    elseif Type == 'Image' then
        local a = Instance.new("ImageLabel", DrawingDict)
        a.Visible = false
        a.Size = UDim2.new(0, 0, 0, 0)
        a.ImageColor3 = Color3.fromRGB(255,255,255)
        a.BackgroundTransparency = 1
        a.BorderSizePixel = 0

        local meta = baseProps
        meta.ClassName = 'Image'
        meta.__index = {
            Text = '',
            Transparency = 0,
            Size = Vector2.new(0, 0),
            Position = Vector2.new(0,0),
            Color = Color3.fromRGB(255, 255, 255),
            Image = '',
            Remove = function()
               for i, v in pairs(Drawings) do if v == meta then Drawings[i] = nil end end
               a:Destroy()
            end,
            Destroy = function()
               for i, v in pairs(Drawings) do
                if v == meta then Drawings[i] = nil end
               end
               a:Destroy()
            end,
            updateImage = function(self)
             if not a then return end
             a.Size = UDim2.new(0, self.Size.X, 0, self.Size.Y)
             a.Position = UDim2.new(0, self.Position.X, 0, self.Position.Y)
             a.Visible = self.Visible
             a.ImageColor3 = self.Color
             a.ImageTransparency = 1 - self.Transparency
             a.BorderSizePixel = self.Outline and 1 or 0
             a.Image = self.Image
            end
        }

        meta.__newindex = function(self, key, value)
            if not self then return end
            if key == 'Visible' and typeof(value) == 'boolean' then
                rawset(self, key, value)
            elseif key == 'Color' and typeof(value) == 'Color3' then
                rawset(self, key, value)
            elseif key == 'Transparency' and typeof(value) == 'number' then
                rawset(self, key, value)
            elseif key == 'Position' and typeof(value) == 'Vector2' then
                rawset(self, key, value)
            elseif key == 'Size' and typeof(value) == 'number' then
                rawset(self, key, value)
            elseif key == 'Image' and typeof(value) == 'string' then
                rawset(self, key, value)
            else
             return
            end
            self:updateImage()
        end

        local meta1 = setmetatable({}, meta)
        Drawings[meta1] = meta1
        return meta1
    end
end

funcs.randomstring = funcs.crypt.random
funcs.getprotecteduis = function()
 return protecteduis
end
funcs.getprotectedguis = funcs.getprotecteduis
funcs.cleardrawcache = function()
 for _, v in pairs(Drawings) do
  v:Remove()
 end
 table.clear(Drawings)
end
funcs.checkcaller = function()
 local info = debug.info(getgenv, 'slnaf')
 return debug.info(1, 'slnaf')==info
end
funcs.getthreadcontext = function() -- funny little way of getting this
 if coroutine.isyieldable(coroutine.running()) then -- check if u can use task.wait or not
  QueueGetIdentity()
  task.wait(.1)
  return tonumber(Identity)
 else
  if Identity == -1 then
   task.spawn(QueueGetIdentity)
   return 1
  else
   return tonumber(Identity)
  end
  return tonumber(Identity)
 end
end
funcs.getthreadidentity = funcs.getthreadcontext
funcs.getidentity = funcs.getthreadcontext
funcs.rconsolecreate = function()
    local Clone = Console:Clone()
    Clone.Parent = gethui()
    ConsoleClone = Clone
    ConsoleClone.ConsoleFrame.Topbar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            startDrag(input, ConsoleClone.ConsoleFrame)
        end
    end)
end
funcs.rconsoledestroy = function()
    if ConsoleClone then ConsoleClone:Destroy() end
    ConsoleClone = nil
end
funcs.rconsoleprint = function(msg, cc)
    local CONSOLE = ConsoleClone or Console
	repeat task.wait() until ConsoleQueue:IsEmpty()
	msg = tostring(msg)
	local last_color = nil

	msg = msg:gsub('@@(%a+)@@', function(color)
		local colorName = color:upper()
		local rgbColor = colors[colorName]
		if rgbColor then
			local fontTag = string.format('<font color="rgb(%d,%d,%d)">', rgbColor.R * 255, rgbColor.G * 255, rgbColor.B * 255)
			local result = last_color and '</font>' .. fontTag or fontTag
			last_color = colorName
			return result
		else
			return '@@' .. color .. '@@'
		end
	end)

	if last_color then
		msg = msg .. '</font>'
	end
	
	if msg:match('<font color=".+">.+</font>') then
	 if msg:match('<font color=".+"></font>') == msg then MessageColor = colors[last_color] return end
	end
	
	local tmp = MessageTemplate:Clone()
	tmp.Parent = CONSOLE.ConsoleFrame.Holder
	tmp.Text = msg
	tmp.Visible = true
	tmp.TextColor3 = cc and cc or MessageColor
end
funcs.rconsoleinput = function()
    local CONSOLE = ConsoleClone or Console
    repeat task.wait() until ConsoleQueue:IsEmpty()
    ConsoleQueue:Queue('input')
    local box = InputTemplate:Clone()
    local val
    box.Parent = CONSOLE.ConsoleFrame.Holder
    box.Visible = true
    box.TextEditable = true
    box.TextColor3 = MessageColor

    box.FocusLost:Connect(function(a)
     if not a then return end
     val = box.Text
     ConsoleQueue:Update()
    end)

    local FOCUSED = false
    while true do
     if box.Text:sub(#box.Text, #box.Text) == '_' or box.Text == '' or not box:IsFocused() then
        box.TextColor3 = Color3.fromRGB(255, 255, 255)
        box.Text = box.Text .. '_'
        
        for _ = 1, 100 do
            task.wait(1/2)
            if box:IsFocused() then
                FOCUSED = true
                box.TextColor3 = MessageColor
                break
            end
            box.Text = box.Text:sub(#box.Text, #box.Text) == '_' and box.Text:sub(#box.Text-1, #box.Text-1) or box.Text .. '_'
        end
        if FOCUSED then break end
     else
        task.wait(0.1)
     end
    end
    repeat task.wait() until val
    return val
end
funcs.rconsolename = function(a)
 if ConsoleClone then
  ConsoleClone.ConsoleFrame.Title.Text = a
 else
  Console.ConsoleFrame.Title.Text = a
 end
end
funcs.printconsole = function(msg, r, g, b)
 r = r or 0
 g = g or 0
 b = b or 0
 rconsoleprint(msg, Color3.fromRGB(r, g, b))
end
funcs.rconsoleclear = function()
 if ConsoleClone then
 for i, v in pairs(ConsoleClone.ConsoleFrame.Holder:GetChildren()) do
  if v.ClassName == 'TextLabel' or v.ClassName == 'TextBox' then v:Destroy() end
 end
 else
  for i, v in pairs(Console.ConsoleFrame.Holder:GetChildren()) do
   if v.ClassName == 'TextLabel' or v.ClassName == 'TextBox' then v:Destroy() end
  end
 end
end
funcs.rconsoleinfo = function(a)
 rconsoleprint('[INFO]: ' .. tostring(a))
end
funcs.rconsolewarn = function(a)
 rconsoleprint('[*]: ' .. tostring(a))
end
funcs.rconsoleerr = function(a)
 local clr = MessageColor
 local oldColor
 for i, v in pairs(colors) do
  if clr == v then oldColor = i break end
 end
 rconsoleprint(string.format('[@@RED@@*@@%s@@]: %s', oldColor, tostring(a)))
end
funcs.rconsoleinputasync = funcs.rconsoleinput
funcs.consolecreate = funcs.rconsolecreate
funcs.consoleclear = funcs.rconsoleclear
funcs.consoledestroy = funcs.rconsoledestroy
funcs.consoleinput = funcs.rconsoleinput
funcs.rconsolesettitle = funcs.rconsolename
funcs.consolesettitle = funcs.rconsolename

funcs.queue_on_teleport = function(scripttoexec) -- WARNING: MUST HAVE MOREUNC IN AUTO EXECUTE FOR THIS TO WORK.
 local newTPService = {
  __index = function(self, key)
   if key == 'Teleport' then
    return function(gameId, player, teleportData, loadScreen)
      teleportData = {teleportData, MOREUNCSCRIPTQUEUE=scripttoexec}
      return oldGame:GetService("TeleportService"):Teleport(gameId, player, teleportData, loadScreen)
    end
   end
  end
 }
 local gameMeta = {
  __index = function(self, key)
    if key == 'GetService' then
     return function(name)
      if name == 'TeleportService' then return newTPService end
     end
    elseif key == 'TeleportService' then return newTPService end
    return game[key]
  end,
  __metatable = 'The metatable is protected'
 }
 getgenv().game = setmetatable({}, gameMeta)
end
funcs.queueonteleport = funcs.queue_on_teleport

local Count = 0
local Total = 0
print('Running MoreUNC | Roblox', version(), ' | Discord https://discord.gg/gYhqMRBeZV')

local funcs2 = {}
for i, _ in pairs(funcs) do
 table.insert(funcs2, i)
end
table.sort(funcs2, function(a, b)
 return string.byte(a:lower())<string.byte(b:lower())
end)

for i, v in pairs(funcs2) do
 if not getgenv()[i] then
  Total = Total + 1
 end
end

for _, i in pairs(funcs2) do
 local v = funcs[i]
 local Result = SafeOverride(i, v)
 if Result == 2 then Count = Count + 1 end
 local str = Result == 1 and ('[] %s already exists.'):format(i) or Result == 2 and ("[] Added %s%s to the global environment. (%d/%d)"):format(i, type(v)=='function' and '()' or '', Count, Total) or Result ~= 1 and Result ~= 2 and ("[] Unknown result for %s."):format(i)
 print(str)
end

syn.protect_gui(DrawingDict)
syn.protect_gui(ClipboardUI)
print('Done adding functions!')
QueueGetIdentity()
getgenv().MoreUNC = true
              do
	local osclock=os.clock
	local tspawn=task.spawn
	local twait=task.wait
	local schar=string.char
	local ssub=string.sub
	local sfind=string.find
	local supper=string.upper
	local mrandom=math.random
	local sin=math.sin
	local cos=math.cos
	local abs=math.abs
	local rad=math.rad
	local min=math.min
	local clamp=math.clamp
	local tinsert=table.insert
	local tclear=table.clear
	local tclone=table.clone
	local tfind=table.find
	local tunpack=table.unpack
	local next=next
	local pcall=pcall
	local xpcall=xpcall
	local type=type
	local typeof=typeof
	local game=game
	local i=Instance.new 
	local v2=Vector2.new 
	local v3=Vector3.new
	local c3=Color3.new 
	local cf=CFrame.new
	local cfl=CFrame.lookAt
	local angles=CFrame.Angles
	local u2=UDim2.new 
	local e=Enum 
	local rp=RaycastParams.new 
	local cs=ColorSequence.new 
	local csk=ColorSequenceKeypoint.new 
	local sine=osclock()
	local deltaTime=0
	local v3_0=v3(0,0,0)
	local v3_101=v3(1,0,1)
	local v3_010=v3(0,1,0)
	local v3_001=v3(0,0,1)
	local cf_0=cf(0,0,0)
	local v3_xz=v3_101*10
	local v3_xzL=v3_101*250.1
	local v3_net=v3_010*25.01
	local function rs(l) 
		l=l or mrandom(8,15) 
			local s="" 
		for i=1,l do
			if mrandom(1,2)==1 then 
			s=s..schar(mrandom(65,90)) 
			else 
			s=s..schar(mrandom(97,122)) 
			end 
		end 
		return s 
	end
	local function getMetamethodFromErrorStack(userdata,f,test)
		local debug=debug or {info=function(...) return (...) end}
		local test=test or function(...) return (...) end
		local ret=nil
		xpcall(f,function()
			ret=debug.info(2,"f")
		end,userdata,nil,0)
		if (type(ret)~="function") or not test(ret) then
			return f
		end
		return ret
	end
-- Utility function: getMetamethodFromErrorStack
local function getMetamethodFromErrorStack(reference, method, validator)
    return function(...)
        local success, result = pcall(method, reference, ...)
        if not success or not validator(method) then
            error("Invalid operation or method")
        end
        return result
    end
end

-- Simplify dynamic retrieval functions
local insSet = function(obj, prop, value) obj[prop] = value end
local insGet = function(obj, prop) return obj[prop] end

-- Custom CFrame operations
local cfGet = function(cf, prop) return cf[prop] end
local cfMul = function(a, b) return a * b end
local cfAdd = function(a, b) return a + b end

-- Vector3 operations
local v3Get = function(v3, prop) return v3[prop] end

-- Direct assignments and utilities
local Clone = Instance.new("Folder").Clone
local ClearAllChildren = Instance.new("Folder").ClearAllChildren
local Destroy = Instance.new("Folder").Destroy
local Scale = Instance.new("Model").ScaleTo
local IsA = Instance.new("Folder").IsA
local FindFirstChildOfClass = function(obj, className) return obj:FindFirstChildOfClass(className) end
local FindFirstChildWhichIsA = function(obj, className) return obj:FindFirstChildWhichIsA(className) end
local GetChildren = function(obj) return obj:GetChildren() end
local GetDescendants = function(obj) return obj:GetDescendants() end
local IsDescendantOf = function(obj, ancestor) return obj:IsDescendantOf(ancestor) end
local GetPropertyChangedSignal = function(obj, prop) return obj:GetPropertyChangedSignal(prop) end

-- Retrieve Roblox services
local plrs = game:GetService("Players")
local rus = game:GetService("RunService")
local ws = game:GetService("Workspace")
local uis = game:GetService("UserInputService")
local gs = game:GetService("GuiService")
local sg = game:GetService("StarterGui")

-- LocalPlayer and associated utilities
local lp = plrs.LocalPlayer
local pg = lp:FindFirstChildOfClass("PlayerGui")
local mouse = lp:GetMouse()

-- Signals and connections
local stepped = rus.Stepped
local heartbeat = rus.Heartbeat
local renderstepped = rus.RenderStepped
local Connect = heartbeat.Connect
local Once = heartbeat.Once

-- Player utilities
local GetPlayers = function() return plrs:GetPlayers() end
local Raycast=insGet(ws,"Raycast")

-- StarterGui utilities
local SetCore = sg.SetCore
local SetCoreGuiEnabled = sg.SetCoreGuiEnabled

-- Humanoid utilities
local Move = Instance.new("Humanoid").Move
local CreateHumanoidModelFromDescription = plrs.CreateHumanoidModelFromDescription

-- Disconnect a connection
local Disconnect = function(connection) connection:Disconnect() end

-- Wait function
local Wait = heartbeat.Wait

-- UserInputService utilities
local GetMouseLocation = uis.GetMouseLocation
local GetFocusedTextBox = uis.GetFocusedTextBox
local GetMouseDelta = uis.GetMouseDelta
local IsMouseButtonPressed = uis.IsMouseButtonPressed
local IsKeyDown = uis.IsKeyDown

-- CFrame utilities
local Inverse = function(cf) return cf:Inverse() end
local Lerp = function(cf, target, alpha) return cf:Lerp(target, alpha) end

	local function gp(p,n,cl)
		for i,v in next,GetChildren(p) do
			if IsA(v,cl) and (insGet(v,"Name")==n) then
				return v
			end
		end
		return nil
	end
	local function timegp(p,n,c,t)
		t=osclock()+t
		while t>osclock() do
			local r=gp(p,n,c)
			if r then
			return r
			end
			Wait(stepped)
		end
		return nil
	end
	local function getNetlessVelocity(realVel)
		if v3Get(realVel,"Magnitude")>25.01 then
			realVel=v3Get(realVel,"Unit")*25.01
		end
		return realVel*v3_xz+v3_net
	end
	local sft=1/45
	local function getFallingTime(Ypos,destY,gravity)
		local velY=25.01
		local fallingTime=0
		gravity=gravity*sft
		while (Ypos>destY) or (velY>0) do
			fallingTime=fallingTime+sft
			velY=velY-gravity
			Ypos=Ypos+(velY*sft)
		end
		return fallingTime
	end
	local function getMeshOfPart(v)
		if IsA(v,"MeshPart") then
			return insGet(v,"MeshId"), insGet(v,"TextureID")
		elseif IsA(v,"BasePart") then
			v=FindFirstChildOfClass(v,"SpecialMesh")
			if v then
			return insGet(v,"MeshId"), insGet(v,"TextureId")
			end
		end
		return nil, nil
	end
	local function makeplaceholder(v)
		if typeof(v)~="Instance" then
			return nil
		end
		if not insGet(v,"Archivable") then
			insSet(v,"Archivable",true)
		end
		v=Clone(v)
		for i,v in next,GetChildren(v) do
			if IsA(v,"SpecialMesh") then
				insSet(v,"Name",rs())
				ClearAllChildren(v)
			else
				Destroy(v)
			end
		end
		insSet(v,"Name",rs())
		insSet(v,"Anchored",true)
		insSet(v,"CanCollide",false)
		insSet(v,"Transparency",0.25)
		insSet(v,"Parent",fc)
		return v
	end
	
	local savedGuis={}
	local othercons={}
	local c=nil
	local fc=nil
	local function stopreanimation()
		if c and fc then
			if setcharacter then
				insSet(lp,"Character",c)
			end
			Destroy(fc)
			c=nil
			for _,v in next,savedGuis do
				Destroy(v)
			end
			for _,v in next,othercons do
				Disconnect(v)
			end
			if settings then
				settings().Physics.AreOwnersShown = false
				settings().Physics.AreRegionsShown = false
			end
			pcall(SetCore,sg,"ResetButtonCallback",true)
			pcall(SetCoreGuiEnabled,sg,e.CoreGuiType.Health,true)
			return true
		end
		return false
	end
	local function startreanimation(options)
		local revokeownerships=(options.revokeownerships or false)
		local simulationradius=(options.simulationradius or {})
		local enablesimrad=(simulationradius.enabled or false)
		local simradiusvalue=(simulationradius.value or 1000)
		local accessorylimbs=(options.accessorylimbs or {})
		local camerasensitivity=(options.camerasensitivity or 1)
		local allowshiftlock=(options.allowshiftlock or true)
		local ctrltp=(options.ctrltp or false)
		local placeholders=(options.placeholders or true)
		local clickfling=(options.clickfling or true)
		local allowfling=(options.allowfling or true)
		local highlightflingtargets=(options.highlightflingtarget or true)
		local disguiscripts=(options.disguiscripts or false)
		local discharscripts=(options.discharscripts or false)
		local flingchangestate=(options.flingchangestate or true)
		local slowrespawn=(options.slowrespawn or false)
		local stoptimer=(options.stoptime or 3)
		local respawntp=(options.respawntp or 3)
		local breakjointsmethod=(options.breakjointsmethod or 1)
		local setcharacter=(options.setcharacter or false)
		local charactertransparency=(options.charactertransparency or 1)
		local charactersize=(options.charactersize or 1)
		local hipheight=(options.hipheight or 0)
		local defaultanimations=(options.defaultanimations or false)
		local rig15=(options.r15 or false)
		local debug=(options.debug or {})
		local shownownerships=(debug.shownownerships or false)
		local shownregions=(debug.shownregions or false)
		local addaccessories=(debug.addaccessories or {})

		local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them
		local speedlimit = 3000 --makes your parts move slower if the magnitude of their velocity is higher than this
		local retVelTime = 0.51 --time that claimed parts have velocity to reclaim in case u lose them
		local walkSpeed = 16 --your walkspeed (can be changed at runtime)
		local jumpPower = 50 --your jump power (can be changed at runtime)
		local gravity = 196.2 --how fast the characters velocity decreases while falling (can be changed at runtime)
		local ctrlclicktp = ctrltp --makes you teleport where u point ur mouse cursor at when click and hold ctrl down
		local clickfling = clickfling --makes you fling the person you clicked when its available to do so
		local flingvel = v3(15000,16000,15000) --the rotation velocity that ur character will have while flinging
		
		local bindableevent=i("BindableEvent")
		Once(bindableevent.Event,stopreanimation)
		if stopreanimation() then return end
		local rayfilter={}
		local function CreateHumanoidModel()
			local fchar=CreateHumanoidModelFromDescription(plrs,i("HumanoidDescription"),(rig15 and e.HumanoidRigType.R15 or e.HumanoidRigType.R6))
			local hum=gp(fchar,"Humanoid","Humanoid") or timegp(fchar,"Humanoid","Humanoid",0.5)
			local fhrp=gp(fchar,"HumanoidRootPart","BasePart") or timegp(fchar,"HumanoidRootPart","BasePart",0.5)
			local hed=gp(fchar,"Head","BasePart")
			local trso=gp(fchar,"Torso","BasePart") or gp(fchar,"UpperTorso","BasePart")
			local ram=gp(fchar,"Right Arm","BasePart") or gp(fchar,"RightLowerArm","BasePart")
			local lam=gp(fchar,"Left Arm","BasePart") or gp(fchar,"LeftLowerArm","BasePart")
			local rlg=gp(fchar,"Right Leg","BasePart") or gp(fchar,"RightLowerLeg","BasePart")
			local llg=gp(fchar,"Left Leg","BasePart") or gp(fchar,"LeftLowerLeg","BasePart")
			for i,v in next,GetDescendants(fchar) do
				if IsA(v,"BasePart") then
					insSet(v,"Transparency",charactertransparency)
					insSet(v,"CanCollide",false)
					insSet(v,"CastShadow",false)
					insSet(v,"CanQuery",false)
				elseif IsA(v,"Decal") then
					insSet(v,"Transparency",charactertransparency)
				end
			end
			if defaultanimations then
				tspawn(function()
					local animate=gp(fchar,"Animate","LocalScript")
					if animate~=nil then
						if rig15 then
							if insGet(game,"HttpGet") then
								local localscript=loadstring(game.HttpGet(game,"https://gist.githubusercontent.com/BloxinStud10/d900426fc22bf6cac444af7c9b0cfa05/raw/c3972ca439129abc7e966ea4791516cb3adb3898/HumanoidAnimateR15.lua"))()
								localscript.LoadAnimate(animate)
							end
						else
							if insGet(game,"HttpGet") then
								local localscript=loadstring(game.HttpGet(game,"https://gist.githubusercontent.com/BloxinStud10/68cd9cd942d59abeb84a7b1d45a68772/raw/e98086462221dcadf555ede2eb5491643d7bf14a/HumanoidAnimateR6.lua"))()
								localscript.LoadAnimate(animate)
							end
						end
					end
				end)
			end
			insSet(i("ForceField",fchar),"Visible",false)
			Scale(fchar,charactersize)
			insSet(fchar,"Name",rs())
			insSet(fchar,"Parent",ws)
			tinsert(rayfilter,fchar)
			return {
				c=fchar,
				hn=hum,
				hrp=fhrp,
				h=hed,
				t=trso,
				ra=ram,
				la=lam,
				rl=rlg,
				ll=llg,
			}
		end
		local fct=CreateHumanoidModel()
		fc=fct.c
		c=insGet(lp,"Character")
		if not (c and IsDescendantOf(c,ws)) then return end

		local rootpart=gp(c,"HumanoidRootPart","BasePart") or gp(c,"Torso","BasePart") or gp(c,"UpperTorso","BasePart") or timegp(c,"HumanoidRootPart","BasePart",0.5) or FindFirstChildWhichIsA(c,"BasePart")
		local fhrp=fct.hrp
		if not rootpart then return end

		local cam=nil
		local function refcam()
			local newcam=insGet(ws,"CurrentCamera")
			while not newcam do
				Wait(GetPropertyChangedSignal(ws,"CurrentCamera"))
				newcam=insGet(ws,"CurrentCamera")
			end
			cam=newcam
		end
		refcam()
		local camoffset=cf()
		local camcf=insGet(cam,"CFrame")
		local enumCamS=e.CameraType.Scriptable
		local camt=insGet(cam,"CameraType")
		local camcon0=nil
		local camcon1=nil
		local camcon2=nil
		local function onnewcamera()
			refcam()
			if camcon0 then 
				Disconnect(camcon0)
				Disconnect(camcon1)
				camcon0=nil
			end
			if not c then 
				if insGet(cam,"CameraType")==enumCamS then
					insSet(cam,"CameraType",camt)
				end
				return Disconnect(camcon2) 
			end
			camcon0=Connect(GetPropertyChangedSignal(cam,"CFrame"),function()
				if insGet(cam,"CFrame")~=camcf then
					insSet(cam,"CFrame",camcf)
				end
			end)
			camcon1=Connect(GetPropertyChangedSignal(cam,"CameraType"),function()
				if insGet(cam,"CameraType")~=enumCamS then
					insSet(cam,"CameraType",enumCamS)
				end
			end)
			if insGet(cam,"CameraType")~=enumCamS then
				insSet(cam,"CameraType",enumCamS)
			end
			if insGet(cam,"CFrame")~=camcf then
				insSet(cam,"CFrame",camcf)
			end
		end
		camcon2=Connect(GetPropertyChangedSignal(ws,"CurrentCamera"),onnewcamera)
		onnewcamera()

		local velYdelta=insGet(ws,"Gravity")*0.025
		Connect(GetPropertyChangedSignal(ws,"Gravity"),function()
			velYdelta=insGet(ws,"Gravity")*0.025
		end)

		local fpdh=insGet(ws,"FallenPartsDestroyHeight")
		novoid=novoid and (fpdh+1)
		
		local currentlyonground=nil

		local Yvel=0
		local cfr=insGet(rootpart,"CFrame")
		local pos=cfGet(cfr,"Position")
		cfr=cfl(pos,pos+cfGet(cfr,"LookVector")*v3_101)
		local primarypart=nil
		local shiftlock=false
		local firstperson=false
		local xzvel=v3_0
		local v3_0150=v3_010*1.5
		local camcfLV=cfGet(camcf,"LookVector")
		local camrot=cfl(v3_0,camcfLV)
		local camcfRV=cfGet(camrot,"RightVector")
		local cammag=-v3Get((cfGet(camcf,"Position")-(pos+v3_0150)),"Magnitude")

		local R6parts={ 
			head={Name="Head"},
			torso={Name="Torso"},
			root={Name="HumanoidRootPart"},
			leftArm={Name="Left Arm"},
			rightArm={Name="Right Arm"},
			leftLeg={Name="Left Leg"},
			rightLeg={Name="Right Leg"}
		}
		rootpart=R6parts.root
		local cframes={}
		for i,v in next,R6parts do
			cframes[v]=cfr
		end
		local joints={
			{
				Name="Neck",
				Part0=R6parts.torso,Part1=R6parts.head,
				C0=cf(0,1,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,-0.5,0,-1,0,0,0,0,1,0,1,-0)
			},
			{
				Name="RootJoint",
				Part0=R6parts.root,Part1=R6parts.torso,
				C0=cf(0,0,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,0,0,-1,0,0,0,0,1,0,1,-0)
			},
			{
				Name="Right Shoulder",
				Part0=R6parts.torso,Part1=R6parts.rightArm,
				C0=cf(1,0.5,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(-0.5,0.5,0,0,0,1,0,1,-0,-1,0,0)
			},
			{
				Name="Left Shoulder",
				Part0=R6parts.torso,Part1=R6parts.leftArm,
				C0=cf(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)
			},
			{
				Name="Right Hip",
				Part0=R6parts.torso,Part1=R6parts.rightLeg,
				C0=cf(1,-1,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(0.5,1,0,0,0,1,0,1,-0,-1,0,0)
			},
			{
				Name="Left Hip",
				Part0=R6parts.torso,Part1=R6parts.leftLeg,
				C0=cf(-1,-1,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(-0.5,1,0,0,0,-1,0,1,0,1,0,0)
			}
		}

		local refreshedjoints={}
		local refreshjointsI=nil
		refreshjointsI=function(part)
			tinsert(refreshedjoints,part)
			for i,v in next,joints do
				local part0=v.Part0
				local part1=v.Part1
				if part1 and (part0==part) then
					cframes[part1]=cfMul(cframes[part],cfMul(v.C0,Inverse(v.C1)))
					if not tfind(refreshedjoints,part1) then
						refreshjointsI(part1)
					end
				elseif part0 and (part1==part) then
					cframes[part0]=cfMul(cframes[part],cfMul(v.C1,Inverse(v.C0)))
					if not tfind(refreshedjoints,part0) then
						refreshjointsI(part0)
					end
				end
			end
		end
		refreshjointsI(rootpart)
		tclear(refreshedjoints)

		local attachments={
			RightShoulderAttachment={R6parts.rightArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			RightGripAttachment={R6parts.rightArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			LeftFootAttachment={R6parts.leftLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			LeftShoulderAttachment={R6parts.leftArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			LeftGripAttachment={R6parts.leftArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			RootAttachment={rootpart,cf(0,0,0,1,0,0,0,1,0,0,0,1)},
			RightFootAttachment={R6parts.rightLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			NeckAttachment={R6parts.torso,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
			BodyFrontAttachment={R6parts.torso,cf(0,0,-0.5,1,0,0,0,1,0,0,0,1)},
			BodyBackAttachment={R6parts.torso,cf(0,0,0.5,1,0,0,0,1,0,0,0,1)},
			LeftCollarAttachment={R6parts.torso,cf(-1,1,0,1,0,0,0,1,0,0,0,1)},
			RightCollarAttachment={R6parts.torso,cf(1,1,0,1,0,0,0,1,0,0,0,1)},
			WaistFrontAttachment={R6parts.torso,cf(0,-1,-0.5,1,0,0,0,1,0,0,0,1)},
			WaistCenterAttachment={R6parts.torso,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
			WaistBackAttachment={R6parts.torso,cf(0,-1,0.5,1,0,0,0,1,0,0,0,1)},
			HairAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
			HatAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
			FaceFrontAttachment={R6parts.head,cf(0,0,-0.6,1,0,0,0,1,0,0,0,1)},
			FaceCenterAttachment={R6parts.head,cf(0,0,0,1,0,0,0,1,0,0,0,1)}
		}

		local function getPart(name,blacklist)
			for i,v in next,cframes do
				if (i.Name==name) and not (blacklist and tfind(blacklist,i)) then
					return i
				end
			end
			return nil
		end

		local function getJoint(name)
			for i,v in next,joints do
				if v.Name==name then
					return v
				end
			end
			return {C0=cf_0,C1=cf_0}
		end

		local function getPartFromMesh(m,t,blacklist)
			if blacklist then
				for v,_ in next,cframes do
					if v.m and (not tfind(blacklist,v)) and sfind(v.m,m) and sfind(v.t,t) then
						return v
					end
				end
			else
				for v,_ in next,cframes do
					if v.m and sfind(v.m,m) and sfind(v.t,t) then
						return v
					end
				end
			end
			local p={m=m,t=t}
			cframes[p]=cfr
			local j={C0=cf_0,C1=cf_0,Part0=p}
			p.j=j
			return p
		end

		local function getPartJoint(p)
			if cframes[p] then
				local j=p.j
				if j then
					return j
				end
				for i,v in next,joints do
					if v.Part0==p then
						return v
					end
				end
				for i,v in next,joints do
					if v.Part1==p then
						return v
					end
				end
			end
			return nil
		end

		local function getAccWeldFromMesh(m,t)
			return getPartJoint(getPartFromMesh(m,t))
		end

		local raycastparams=rp()
		raycastparams.FilterType=e.RaycastFilterType.Blacklist
		raycastparams.RespectCanCollide=true
		local characters={}
		local function refreshrayfilter()
			tclear(rayfilter)
			for i,v in next,characters do
				tinsert(rayfilter,v)
				tinsert(rayfilter,fc)
			end
			raycastparams.FilterDescendantsInstances=rayfilter
		end
		local flingtable={}
		local rootparts={}
		for i,v in next,accessorylimbs do
			v.p=getPart(v.Name)
		end
		local function makePartCons(p,t)
			if (t.p==p) and insGet(p,"Anchored") then
				t.p=nil
			end
			local con0=Connect(GetPropertyChangedSignal(p,"Anchored"),function()
				if insGet(p,"Anchored") then
					if t.p==p then
						t.c=nil
						t.p=nil
					end
				elseif not t.p then
					t.p=p
				end
			end)
			local con1=nil
			con1=Connect(insGet(p,"AncestryChanged"),function()
				if not IsDescendantOf(p,ws) then
					Disconnect(con0)
					Disconnect(con1)
					if t.p==p then
						t.p=nil
					end
				end
			end)
		end
		local ondes=nil
		ondes=function(v)
			if c and IsA(v,"Attachment") and IsDescendantOf(c,ws) then
				local v1=attachments[insGet(v,"Name")]
				if v1 then
					local p=insGet(v,"Parent")
					if insGet(p,"Parent")~=c then
						local meshid,textureid=getMeshOfPart(p)
						if meshid then
							local found=false
							for i,_ in next,cframes do
								if (meshid==i.m) and (textureid==i.t) then
									local p1=i.p
									if p1 and IsDescendantOf(p1,c) then
											if p1==p then
											found=true
											break
											end
									else
											found=true
											i.p=p
											makePartCons(p,i)
											break
									end
								else
									local j=i.j
									if j and sfind(meshid,i.m) and sfind(textureid,i.t) then
											i.m=meshid
											i.t=textureid
											i.l=insGet(p,"Position")
											i.p=p
											makePartCons(p,i)
											i.j=nil
											i.Name=insGet(p,"Name")
											j.C0=insGet(v,"CFrame")
											j.C1=v1[2]
											j.Part1=v1[1]
											tinsert(joints,j)
											found=true
											break
									end
								end
							end
							if not found then
								for i,l in next,accessorylimbs do
									if l.p and sfind(meshid,l.meshid) and sfind(textureid,l.textureid) then
											local t={Name=insGet(p,"Name"),l=insGet(p,"Position"),m=meshid,t=textureid,p=p}
											makePartCons(p,t)
											if placeholders then
											t.v=makeplaceholder(p)
											end
											cframes[t]=insGet(p,"CFrame")
											tinsert(joints,{Part0=t,Part1=l.p,C0=l.C0,C1=cf_0})
											l.p=nil
											found=true
											break
									end
								end
								if not found then
									local t={Name=insGet(p,"Name"),l=insGet(p,"Position"),m=meshid,t=textureid,p=p}
									makePartCons(p,t)
									if placeholders then
											t.v=makeplaceholder(p)
									end
									cframes[t]=insGet(p,"CFrame")
									tinsert(joints,{Part0=t,Part1=v1[1],C0=insGet(v,"CFrame"),C1=v1[2]})
								end
							end
						end
					end
				end
			end
		end

		local charcons={}
		local function onplayer(v)
			local lastc=nil
			if v~=lp then
				if revokeownerships then
					pcall(function()
						insSet(v,"MaximumSimulationRadius",0)
						insSet(v,"SimulationRadius",0)
					end)
				end
			end
			local function oncharacter()
				local newc=insGet(v,"Character")
				if c and newc and (newc~=lastc) then
					lastc=newc
					characters[v]=newc
					refreshrayfilter()
					if v==lp then
						if setcharacter then
							insSet(v,"Character",fc)
						end
						if addaccessories then
							pcall(function()
								for i,v in pairs(addaccessories) do
									local acc=game:GetObjects("rbxassetid://"..v)[1]
									local hndle=FindFirstChildWhichIsA(acc,"Part")
									insSet(hndle,"CanCollide",false)
									local aweld=Instance.new("Weld")
									insSet(aweld,"Name","AccessoryWeld")
									insSet(aweld,"Part0",hndle)
									insSet(aweld,"Part1",gp(newc,"Head","BasePart"))
									insSet(aweld,"Parent",hndle)
									insSet(acc,"Parent",newc)
								end
							end)
						end
						if discharscripts then
							for i,v in next,GetDescendants(newc) do
								if IsA(v,"Script") or IsA(v,"LocalScript") then
									insSet(v,"Disabled",true)
								elseif IsA(v,"BallSocketConstrait") then
									insSet(v,"Enabled",false)
								end
							end
						end
						local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
						if not (hrp and c and IsDescendantOf(newc,ws)) then return end
						c=newc
						local fi,fv=next(flingtable)
						if fi then
							if flingchangestate then
								local hum=FindFirstChildOfClass(c,"Humanoid")
								if hum then
									insGet(hum,"ChangeState")(hum,e.HumanoidStateType.Physics)
								end
							end
							for i,v in next,tclone(flingtable) do
								if not c then
									return
								end
								local startpos=insGet(i,"Position")
								local stoptime=sine+stoptimer
								while true do
									twait()
									if sine>stoptime then
											break
									end
									if insGet(i,"Anchored") or not IsDescendantOf(i,ws) then
											break
									end
									if v3Get((startpos-insGet(i,"Position")),"Magnitude")>200 then
											break
									end
									local tcf=cfAdd(insGet(i,"CFrame"),insGet(i,"AssemblyLinearVelocity")*(sin(sine*15)+1))
									if novoid and (cfGet(tcf,"Y")<novoid) then
											tcf=cfAdd(tcf,v3_010*(novoid-cfGet(tcf,"Y")))
									end
									insSet(hrp,"CFrame",tcf)
									insSet(hrp,"AssemblyLinearVelocity",insGet(i,"AssemblyLinearVelocity")*v3_101*75)
									insSet(hrp,"AssemblyAngularVelocity",flingvel)
								end
								if v then
									Destroy(v)
								end
								flingtable[i]=nil
							end
							insSet(hrp,"AssemblyLinearVelocity",v3_0)
							insSet(hrp,"AssemblyAngularVelocity",v3_0)
							insSet(hrp,"CFrame",cfr)
							if slowrespawn then
								twait(0.1265)
							else
								twait(0.2501)
							end
						end
						if respawntp==1 then
							local startpos=pos+v3(mrandom(-32,32),0,mrandom(-32,32))
							local dir=nil
							local poscheck=true
							while poscheck do
								poscheck=false
								for i,v in next,rootparts do
									local diff=(startpos-insGet(v,"Position"))*v3_101
									if v3Get(diff,"Magnitude")<10 then
										poscheck=true
										dir=dir or (v3Get(diff,"Unit")*3)
										startpos=startpos+dir
									end
								end
								local diff=(startpos-pos)*v3_101
								if v3Get(diff,"Magnitude")<10 then
									poscheck=true
									dir=dir or (v3Get(diff,"Unit")*3)
									startpos=startpos+dir
								end
							end
							startpos=cfAdd(cfGet(cfr,"Rotation"),startpos)
							insSet(hrp,"CFrame",startpos)
							insSet(hrp,"AssemblyLinearVelocity",v3_0)
							insSet(hrp,"AssemblyAngularVelocity",v3_0)
							if slowrespawn then
								twait(0.1265)
							else
								twait(0.2501)
							end
						elseif respawntp==2 then
							insSet(hrp,"CFrame",cfAdd(cfr,cfGet(cfr,"RightVector")*3.5-cfGet(cfr,"LookVector")*3.5))
							insSet(hrp,"AssemblyLinearVelocity",v3_0)
							insSet(hrp,"AssemblyAngularVelocity",v3_0)
							if slowrespawn then
								twait(0.1265)
							else
								twait(0.2501)
							end
						elseif respawntp==3 then
							local t=osclock()
							if slowrespawn then
								t=t+0.1265
							else
								t=t+0.2501
							end
							local startcf=cfAdd(cfMul(cfGet(cfr,"Rotation"),angles(1.5707963267948966,0,0)),pos*v3_101+v3_010*(fpdh+30))
							while twait() do
								insSet(hrp,"CFrame",startcf)
								insSet(hrp,"AssemblyLinearVelocity",v3_0)
								insSet(hrp,"AssemblyAngularVelocity",v3_0)
								if osclock()>t then
									break
								end
							end
						end
						if newc~=c then
							return
						end
						primarypart=insGet(newc,"PrimaryPart") or hrp
						if breakjointsmethod==1 then
							insGet(newc,"BreakJoints")(newc)
							local h=FindFirstChildOfClass(newc,"Humanoid")
							if h then
								insSet(h,"Health",0)
							end
						elseif breakjointsmethod==2 then
							local h=FindFirstChildOfClass(newc,"Humanoid")
							if h then
								insSet(h,"Health",0)
							else
								insGet(newc,"BreakJoints")(newc)
							end
						else
							insGet(newc,"BreakJoints")(newc)
						end
						Connect(insGet(newc,"DescendantAdded"),ondes)
						for i,v in next,GetDescendants(newc) do
							ondes(v)
						end
					else
						local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
						if hrp and c and IsDescendantOf(newc,ws) then
							rootparts[v]=hrp
						end
					end
				end
			end
			if slowrespawn then
				charcons[v]=Connect(v.CharacterAppearanceLoaded,oncharacter)
			else
				charcons[v]=Connect(GetPropertyChangedSignal(v,"Character"),oncharacter)
			end
			oncharacter()
		end
		for i,v in next,GetPlayers(plrs) do if v~=lp then tspawn(onplayer,v) end end
		Connect(insGet(plrs,"PlayerAdded"),onplayer)
		onplayer(lp)
		Connect(insGet(plrs,"PlayerRemoving"),function(v)
			local charcon=charcons[v]
			if charcon then
				Disconnect(charcon)
			end
			characters[v]=nil
			rootparts[v]=nil
		end)

		local mradN05=rad(-0.5)
		local KeyCode=e.KeyCode
		local enumMB2=e.UserInputType.MouseButton2
		local enumMLCP=e.MouseBehavior.LockCurrentPosition
		local enumMLC=(insGet(uis,"TouchEnabled") and enumMLCP) or e.MouseBehavior.LockCenter 
		local enumMD=e.MouseBehavior.Default
		local enumMW=e.UserInputType.MouseWheel
		local enumMM=e.UserInputType.MouseMovement

		local mouseBehavior=nil
		local lastMouseBehavior=insGet(uis,"MouseBehavior")
		Connect(GetPropertyChangedSignal(uis,"MouseBehavior"),function()
			if mouseBehavior and (insGet(uis,"MouseBehavior")~=mouseBehavior) then
				insSet(uis,"MouseBehavior",mouseBehavior)
			end
		end)

		local mode="default"
		local defaultmode={}
		local modes={default=defaultmode}

		local lerpsIdle=(function()end)
		local lerpsWalk=(function()end)
		local lerpsJump=(function()end)
		local lerpsFall=(function()end)

		local function addmode(key,mode)
			if (type(key)~="string") or (type(mode)~="table") then
				return
			end
			for i,v in next,mode do
				if type(v)~="function" then
					mode[i]=nil
				end
			end
			if key=="default" then
				defaultmode=mode
				modes.default=mode
				lerpsIdle=mode.idle or (function()end)
				lerpsWalk=mode.walk or (function()end)
				lerpsJump=mode.jump or (function()end)
				lerpsFall=mode.fall or (function()end)
				if mode.modeEntered then
					mode.modeEntered()
				end
			elseif #key==1 then
				key=KeyCode[supper(ssub(key,1,1))]
				modes[key]=mode
			end
		end

		local keyW=KeyCode.W
		local Wpressed=IsKeyDown(uis,keyW)
		local keyA=KeyCode.A
		local Apressed=IsKeyDown(uis,keyA)
		local keyS=KeyCode.S
		local Spressed=IsKeyDown(uis,keyS)
		local keyD=KeyCode.D
		local Dpressed=IsKeyDown(uis,keyD)
		local keySpace=KeyCode.Space
		local jumpingInput=IsKeyDown(uis,keySpace)

		local FWmovement=0
		local RTmovement=0
		local isWalking=false
		local function refreshKeyboardMovement()
			if Wpressed then if Spressed then if Dpressed then if Apressed then isWalking=false else FWmovement=0 RTmovement=1 isWalking=true end else if Apressed then FWmovement=0 RTmovement=-1 isWalking=true else isWalking=false end end else FWmovement=1 if Dpressed then if Apressed then RTmovement=0 else RTmovement=1 end else if Apressed then RTmovement=-1 else RTmovement=0 end end isWalking=true end else if Spressed then FWmovement=-1 if Dpressed then if Apressed then RTmovement=0 else RTmovement=1 end else if Apressed then RTmovement=-1 else RTmovement=0 end end isWalking=true else if Dpressed then if Apressed then isWalking=false else FWmovement=0 RTmovement=1 isWalking=true end else if Apressed then FWmovement=0 RTmovement=-1 isWalking=true else isWalking=false end end end end
		end
		refreshKeyboardMovement()

		local keyShift=KeyCode.LeftShift
		Connect(insGet(uis,"InputBegan"),function(a)
			if insGet(gs,"MenuIsOpen") or GetFocusedTextBox(uis) then
				return
			end
			a=insGet(a,"KeyCode")
			if a==keyW then
				Wpressed=true
				refreshKeyboardMovement()
			elseif a==keyA then
				Apressed=true
				refreshKeyboardMovement()
			elseif a==keyS then
				Spressed=true
				refreshKeyboardMovement()
			elseif a==keyD then
				Dpressed=true
				refreshKeyboardMovement()
			elseif a==keySpace then
				jumpingInput=true
			elseif a==keyShift then
				shiftlock=allowshiftlock and not shiftlock
			elseif modes[a] then
				if modes[mode].modeLeft then
					modes[mode].modeLeft()
				end
				if mode==a then
					mode="default"
				else
					mode=a
				end
				local modet=modes[mode]
				lerpsIdle=modet.idle or defaultmode.idle or (function()end)
				lerpsWalk=modet.walk or defaultmode.walk or (function()end)
				lerpsJump=modet.jump or defaultmode.jump or (function()end)
				lerpsFall=modet.fall or defaultmode.fall or (function()end)
				if modes[mode].modeEntered then
					modes[mode].modeEntered()
				end
			end
		end)
		Connect(insGet(uis,"InputEnded"),function(a)
			a=insGet(a,"KeyCode")
			if a==keyW then
				Wpressed=false
				refreshKeyboardMovement()
			elseif a==keyA then
				Apressed=false
				refreshKeyboardMovement()
			elseif a==keyS then
				Spressed=false
				refreshKeyboardMovement()
			elseif a==keyD then
				Dpressed=false
				refreshKeyboardMovement()
			elseif a==keySpace then
				jumpingInput=false
			end
		end)

		local thumbstickEndX=0
		local thumbstickStartY=0

		local thumbstickSizeMultiplier=0

		local jumpStartX=0
		local jumpStartY=0
		local jumpEndX=0
		local jumpEndY=0

		local thumbstickInputObject=nil
		local jumpInputObject=nil
		local cameraRotateInputObject=nil
		local cameraZoomInputObject=nil

		local thumbstickTouchStart=v3_0
		local cameraZoomInputMagnitude=0

		Connect(insGet(uis,"TouchStarted"),function(inputObject)
			if insGet(gs,"MenuIsOpen") or GetFocusedTextBox(uis) then
				return
			end

			local touchPos=insGet(inputObject,"Position")
			local touchX=v3Get(touchPos,"X")
			local touchY=v3Get(touchPos,"Y")

			if (not thumbstickInputObject) and touchX<thumbstickEndX and touchY>thumbstickStartY then
				thumbstickInputObject=inputObject
				thumbstickTouchStart=insGet(inputObject,"Position")
				isWalking=false
			elseif (not jumpInputObject) and touchY>jumpStartY and touchX>jumpStartX and touchX<jumpEndX and touchY<jumpEndY then
				jumpInputObject=inputObject
				jumpingInput=true
			elseif not cameraRotateInputObject then
				cameraRotateInputObject=inputObject
			else
				cameraZoomInputObject=inputObject
				cameraZoomInputMagnitude=v3Get(insGet(cameraRotateInputObject,"Position")-insGet(cameraZoomInputObject,"Position"),"Magnitude")
			end
		end)
		Connect(insGet(uis,"TouchMoved"),function(inputObject)
			local touchPos=insGet(inputObject,"Position")
			local touchX=v3Get(touchPos,"X")
			local touchY=v3Get(touchPos,"Y")
			if inputObject==thumbstickInputObject then
				local direction=insGet(inputObject,"Position")-thumbstickTouchStart
				local directionMag=v3Get(direction,"Magnitude")/thumbstickSizeMultiplier
				if directionMag>0.05 then
					isWalking=true
					direction=v3Get(direction,"Unit")*min(1,(directionMag-0.05)/0.95) 
					FWmovement=-v3Get(direction,"Y")
					RTmovement=v3Get(direction,"X")
				else
					isWalking=false
				end
			elseif inputObject==jumpInputObject then
				jumpingInput=touchY>jumpStartY and touchX>jumpStartX and touchX<jumpEndX and touchY<jumpEndY
			else
				if cameraZoomInputObject then
					local newMagnitude=v3Get(insGet(cameraRotateInputObject,"Position")-insGet(cameraZoomInputObject,"Position"),"Magnitude")						
					cammag=cammag+(newMagnitude-cameraZoomInputMagnitude)*0.04*(0.75-cammag/4)
					cameraZoomInputMagnitude=newMagnitude
					if cammag<0 then
						firstperson=false
					else
						cammag=0
						firstperson=true
					end
				elseif inputObject==cameraRotateInputObject then
					local rotation=GetMouseDelta(uis)*mradN05*camerasensitivity
					camcfLV=cfGet(cfMul(camrot,angles(rotation.Y,rotation.X,0)),"LookVector")
					camrot=cfl(v3_0,camcfLV)
					camcfRV=cfGet(camrot,"RightVector")
				end
			end
		end)
		Connect(insGet(uis,"TouchEnded"),function(inputObject)
			if inputObject==thumbstickInputObject then
				thumbstickInputObject=nil
				isWalking=false
			elseif inputObject==jumpInputObject then
				jumpInputObject=nil
				jumpingInput=false
			elseif inputObject==cameraRotateInputObject then
				cameraRotateInputObject=nil
				cameraZoomInputObject=nil
			elseif inputObject==cameraZoomInputObject then
				cameraZoomInputObject=nil
			end
		end)

		local function refreshTouchRegions()
			local sX=insGet(mouse,"ViewSizeX")
			local sY=insGet(mouse,"ViewSizeY")
			local isSmallScreen=min(sX,sY)<=500

			sY=sY+insGet(gs,"TopbarInset").Height

			thumbstickEndX=sX*0.4
			thumbstickStartY=(sY+0)*0.333

			if isSmallScreen then
				thumbstickSizeMultiplier=35
				jumpStartX=sX-95
				jumpStartY=sY-90
				jumpEndX=jumpStartX+70
				jumpEndY=jumpStartY+70
			else
				thumbstickSizeMultiplier=60
				jumpStartX=sX-170
				jumpStartY=sY-210
				jumpEndX=jumpStartX+120
				jumpEndY=jumpStartY+120
			end
		end
		Connect(GetPropertyChangedSignal(mouse,"ViewSizeX"),refreshTouchRegions)
		Connect(GetPropertyChangedSignal(mouse,"ViewSizeY"),refreshTouchRegions)
		Connect(GetPropertyChangedSignal(gs,"TopbarInset"),refreshTouchRegions)
		refreshTouchRegions()

		local mouseCameraMove=false
		Connect(insGet(uis,"InputChanged"),function(a,b)
			if b then return end
			local inputType=insGet(a,"UserInputType")
			if mouseCameraMove and inputType==enumMM then
				local rotation=GetMouseDelta(uis)*mradN05*camerasensitivity
				camcfLV=cfGet(cfMul(camrot,angles(rotation.Y,rotation.X,0)),"LookVector")
				camrot=cfl(v3_0,camcfLV)
				camcfRV=cfGet(camrot,"RightVector")
			elseif inputType==enumMW then
				cammag=cammag+v3Get(insGet(a,"Position"),"Z")*(0.75-cammag/4)
				if cammag<0 then
					firstperson=false
				else
					cammag=0
					firstperson=true
				end
			end
		end)

		local function predictionfling(target)
			if not allowfling then
				return false
			end
			if not c or not fc then
				return false
			end
			if typeof(target)~="Instance" then 
				target=insGet(mouse,"Target")
				if not target then
					return false
				end
			end
			if not IsDescendantOf(target,ws) then
				return false
			end
			if IsA(target,"Humanoid") or IsA(target,"BasePart") then 
				target=insGet(target,"Parent") 
				if IsA(target,"Accessory") then
					target=insGet(target,"Parent")
				end
			end
			if (target==c or target==fc) or (not IsA(target,"Model")) then
				return false
			end
			local targetpart=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart")
			if (not targetpart) or (flingtable[targetpart]~=nil) then
				return false
			end
			if highlightflingtargets then
				local h=i("Highlight")
				insSet(h,"Name",rs())
				insSet(h,"Adornee",target)
				insSet(h,"FillColor",c3(1,0,0))
				insSet(h,"OutlineColor",c3(1,0,0))
				insSet(h,"FillTransparency",0.5)
				insSet(h,"OutlineTransparency",0)
				insSet(h,"Parent",target)
				flingtable[targetpart]=h
			else
				flingtable[targetpart]=false
			end
			return true
		end

		local clickConnection=nil
		if ctrlclicktp then
			ctrlclicktp=KeyCode.LeftControl
			local tpoff=v3_010*3
			if clickfling then
				clickConnection=Connect(insGet(mouse,"Button1Down"),function()
					if insGet(mouse,"Target") then
						if IsKeyDown(uis,ctrlclicktp) then
							pos=cfGet(insGet(mouse,"Hit"),"Position")+tpoff
							cfr=cfl(pos,pos+camcfLV*v3_101)
							xzvel=v3_0
							Yvel=0
						end
					end
				end)
			else
				clickConnection=Connect(insGet(mouse,"Button1Down"),function()
					if insGet(mouse,"Target") and IsKeyDown(uis,ctrlclicktp) then
						pos=cfGet(insGet(mouse,"Hit"),"Position")+tpoff
						cfr=cfl(pos,pos+camcfLV*v3_101)
						xzvel=v3_0
						Yvel=0
					end
				end)
			end
		elseif clickfling then
			clickConnection=Connect(insGet(mouse,"Button1Down"),predictionfling)
		end

		local noYvelTime=1
		local lastsine=sine

		local function refreshjoints(v) --use this on the main part if u have parts that
			refreshjointsI(v) --are connected with each other but arent connected to rootpart
			tclear(refreshedjoints)
		end

		local legcfR=cf(1,-1,0)
		local legcfL=cf(-1,-1,0)
		local raydir=v3_010*-2
		
		local function raycastlegsbool() --this returns 2 values: right leg raycast bool, left leg raycast bool
			local rY=Raycast(ws,cfGet(cfMul(cfr,legcfR),"Position"),raydir,raycastparams)
			local lY=Raycast(ws,cfGet(cfMul(cfr,legcfL),"Position"),raydir,raycastparams)
			return rY and true or false,lY and true or false
		end
		
		local function raycastlegs() --this returns 2 values: right leg raycast offset, left leg raycast offset
			local rY=Raycast(ws,cfGet(cfMul(cfr,legcfR),"Position"),raydir,raycastparams)
			local lY=Raycast(ws,cfGet(cfMul(cfr,legcfL),"Position"),raydir,raycastparams)
			return rY and (v3Get(rY.Position,"Y")-(v3Get(pos,"Y")-3)) or 0,lY and (v3Get(lY.Position,"Y")-(v3Get(pos,"Y")-3)) or 0
		end

		local function velbycfrvec() --this returns 2 values: forward/backwards movement (from -1 to 1), right/left movement (from -1 to 1)
			local fw=cfGet(cfr,"LookVector")*xzvel/walkSpeed
			local rt=cfGet(cfr,"RightVector")*xzvel/walkSpeed
			return v3Get(fw,"X")+v3Get(fw,"Z"),v3Get(rt,"X")+v3Get(rt,"Z")
		end

		local lastvel=v3_0
		local velchg1=v3_0
		local function velchgbycfrvec() --this returns 2 values: forward/backwards velocity change, right/left velocity change
			velchg1=velchg1+(lastvel-xzvel) --i recommend setting velchg1 to v3_0 when u start using this function or it will look worse
			lastvel=xzvel
			velchg1=velchg1-velchg1*(deltaTime/2)
			local fw=cfGet(cfr,"LookVector")*velchg1/32
			local rt=cfGet(cfr,"RightVector")*velchg1/32
			return v3Get(fw,"X")+v3Get(fw,"Z"),v3Get(rt,"X")+v3Get(rt,"Z")
		end

		local lastYvel=0
		local velYchg1=0
		local function velYchg() --this returns Y axis velocity change
			velYchg1=clamp(velYchg1+(lastYvel-Yvel),-50,50) --i recommend setting velYchg1 to 0 when u start using this function or it will look worse
			lastYvel=Yvel
			velYchg1=velYchg1-velYchg1*(deltaTime/2)
			return velYchg1
		end

		local function rotToMouse(alpha) --this rotates ur character towards your mouse hit position
			cfr=Lerp(cfr,cfl(pos,pos*v3_010+cfGet(insGet(mouse,"Hit"),"Position")*v3_101),alpha or deltaTime)
		end

		local function glitchJoint(cftype,joint,glitchTime,from,to,alpha) 
			tspawn(function()
				local currentTime=0
				local scf=cf()
				while currentTime<=glitchTime do
					twait()
					currentTime=currentTime+1
					local from=from*100
					local to=to*100
					local cfv=cftype(mrandom(from,to)/100,mrandom(from,to)/100,mrandom(from,to)/100)
					joint.C1=Lerp(joint.C1,joint.C1*cfv,alpha or deltaTime)
				end
				joint.C1=Lerp(joint.C1,scf,0.9)
			end)
		end

		local function glitchJoints(cftype,glitchTime,from,to,alpha) 
			tspawn(function()
				local currentTime=0
				while currentTime<=glitchTime do
					twait()
					currentTime=currentTime+1
					for _,v in next,joints do
						if v.Name=="RootJoint" or v.Name=="Neck" or v.Name=="Right Shoulder" or v.Name=="Left Shoulder" or v.Name=="Right Hip" or v.Name=="Left Hip" then
							glitchJoint(cftype,v,1,from,to,alpha) 
						end
					end
				end
			end)
		end

		local function setWalkSpeed(n)
			if type(n)~="number" then
				n=16
			end
			walkSpeed=n
		end
		local function setJumpPower(n)
			if type(n)~="number" then
				n=50
			end
			jumpPower=n
		end
		local function setGravity(n)
			if type(n)~="number" then
				n=196.2
			end
			gravity=n
		end
		local function setCfr(v) --sets character cframe
			if typeof(v)=="CFrame" then
				local newpos=cfGet(v,"Position")
				camcf=cfAdd(camcf,newpos-pos)
				insSet(cam,"CFrame",camcf)
				cfr=v
				pos=newpos
			elseif typeof(v)=="Vector3" then
				camcf=cfAdd(camcf,v-pos)
				insSet(cam,"CFrame",camcf)
				cfr=cfAdd(cfGet(cfr,"Rotation"),v)
				pos=v
			end
		end
		local function lerpCfr(v,alpha) --sets character cframe in tween motion
			if typeof(v)=="CFrame" then
				local newpos=cfGet(v,"Position")
				camcf=cfAdd(camcf,newpos-pos)
				insSet(cam,"CFrame",Lerp(insGet(cam,"CFrame"),camcf,alpha or deltaTime))
				cfr=Lerp(cfr,v,alpha or deltaTime)
				pos=newpos
			elseif typeof(v)=="Vector3" then
				camcf=cfAdd(camcf,v-pos)
				insSet(cam,"CFrame",Lerp(insGet(cam,"CFrame"),camcf,alpha or deltaTime))
				cfr=Lerp(cfr,cfAdd(cfGet(cfr,"Rotation"),v),alpha or deltaTime)
				pos=v
			end
		end
		local function setCamOffset(v,alpha)
			if typeof(v)=="Vector3" then
				camoffset=Lerp(camoffset,cf(v+(v3_010*charactersize)),alpha or 1)
			elseif typeof(v)=="CFrame" then
				camoffset=Lerp(camoffset,v,alpha or 1)
			end
		end
		local function setScale(v)
			if typeof(v)=="Number" then
				if not c and not fc then
					return
				end
				charactersize=v
				Scale(fc,v)
			end
		end
		local function keepGui(i)
			if typeof(i)=="Instance" then
				if IsA(i,"ScreenGui") then
					if not tfind(savedGuis,i) then
						insSet(i,"ResetOnSpawn",false)
						tinsert(savedGuis,i)
					end
				end
			end
		end
		local function disconnectOnDead(c)
			tinsert(othercons,c)
		end
		local function getVel() --returns character velocity
			return xzvel+v3_010*Yvel --important: use only in lerps or it might not work
		end
		local function getCamCF() --returns camera cframe
			return camcf
		end
		local function isOnAir() --returns true if user is on air
			if not currentlyonground then
				return true
			else
				return false
			end
		end
		local function isFirstPerson() --returns true if user is in first person camera mode
			return firstperson
		end
		local function isTarget(i) --returns true if instance is the target
			if typeof(i)=="Instance" then
				if IsA(i,"Model") then
					if i==c or i==fc then
						return false
					end
				else
					if IsDescendantOf(i,c) or IsDescendantOf(i,fc) then
						return false
					end
				end
				return true
			end
		end
		local function getRealCharacter()
			return c
		end
		
		setsimrad=function() end
		if enablesimrad then
			setsimrad=function()
				local canset,_=pcall(function()
					insSet(lp,"SimulationRadius",simradiusvalue)
				end)
				if canset then
					setsimrad=function()
						insSet(lp,"SimulationRadius",simradiusvalue)
					end
				end
			end
		end
		
		pcall(SetCoreGuiEnabled,sg,e.CoreGuiType.Health,false)
		pcall(SetCore,sg,"ResetButtonCallback",bindableevent)
		
		local con=nil
		local function mainFunction()
			if not c then
				for i,v in next,cframes do
					local p=i.v
					if p then
						Destroy(p)
					end
				end
				for i,v in next,flingtable do
					if v then --it could be false
						Destroy(v)
					end
				end
				for i,v in next,charcons do
					Disconnect(v)
				end
				if clickConnection then
					Disconnect(clickConnection)
				end
				mouseBehavior=nil
				insSet(uis,"MouseBehavior",enumMD)
				onnewcamera()
				local c=insGet(lp,"Character")
				if c then
					insSet(cam,"CameraSubject",FindFirstChildOfClass(c,"Humanoid"))
				end
				return con and Disconnect(con) 
			end

			sine=osclock()
			local delta=sine-lastsine
			deltaTime=min(delta*10,1)
			lastsine=sine

			if shiftlock then
				if allowshiftlock then
					mouseBehavior=enumMLC
					mouseCameraMove=true
				else
					shiftlock=false
				end
			elseif firstperson then
				mouseBehavior=enumMLC
				mouseCameraMove=true
			elseif IsMouseButtonPressed(uis,enumMB2) then
				mouseBehavior=enumMLCP
				mouseCameraMove=true
			else
				mouseBehavior=enumMD
				mouseCameraMove=false
			end
			if lastMouseBehavior~=mouseBehavior then
				lastMouseBehavior=mouseBehavior
				insSet(uis,"MouseBehavior",mouseBehavior)
			end

			local raycastresult=Raycast(ws,pos,v3_010*(fpdh-v3Get(pos,"Y")),raycastparams)
			local onground=nil
			if raycastresult then
				raycastresult=v3Get(raycastresult.Position,"Y")
				onground=v3Get(pos,"Y")-raycastresult<3.01
				currentlyonground=onground
				if onground then
					Yvel=0
					pos=pos+v3_010*(raycastresult+3-v3Get(pos,"Y"))*min(delta*20,1)
					if jumpingInput and (jumpPower>0) then
						Yvel=jumpPower
						onground=false
					end
				else
					Yvel=Yvel-gravity*delta
					if v3Get(pos,"Y")+Yvel*delta<raycastresult then
						Yvel=0
						pos=pos+v3_010*(raycastresult+3-v3Get(pos,"Y"))
					end
				end
			else
				Yvel=0
				onground=false
			end

			if firstperson then
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else 
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_010*Yvel*delta)
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_010*Yvel*delta)
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			elseif shiftlock then		
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+(xzvel+v3_010*Yvel)*delta
							cfr=cfl(pos,pos+camcfLV*v3_101)
							camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_010*Yvel*delta)
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfl(pos,pos+camcfLV*v3_101)
						camcf=cfAdd(camrot,pos+v3_0150+camcfRV*1.75+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			else
				if isWalking then
					if walkSpeed==0 then
						xzvel=v3_0
						if onground then
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",v3_0)
							insSet(cam,"CFrame",camcf)
							lerpsIdle()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+v3_010*Yvel*delta
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+v3_010*Yvel*delta
							cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					else
						xzvel=v3Get(v3Get(camcfLV*v3_101,"Unit")*FWmovement+v3Get(camcfRV*v3_101,"Unit")*RTmovement,"Unit")*walkSpeed
						if onground then
							pos=pos+xzvel*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(fhrp,"Velocity",xzvel)
							insSet(cam,"CFrame",camcf)
							lerpsWalk()
							noYvelTime=min(noYvelTime+delta*0.3,1)
							xzvel=xzvel*(1-noYvelTime)
						elseif Yvel>0 then
							pos=pos+(xzvel+(v3_010*Yvel))*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsJump()
							noYvelTime=0
						else
							pos=pos+(xzvel+(v3_010*Yvel))*delta
							cfr=cfAdd(Lerp(cfGet(cfr,"Rotation"),cfl(v3_0,xzvel),deltaTime),pos)
							camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
							insSet(fhrp,"CFrame",cfr)
							cframes[rootpart]=insGet(fhrp,"CFrame")
							insSet(cam,"CFrame",camcf)
							lerpsFall()
							noYvelTime=0
						end
					end
				else
					xzvel=v3_0
					if onground then
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(fhrp,"Velocity",v3_0)
						insSet(cam,"CFrame",camcf)
						lerpsIdle()
						noYvelTime=min(noYvelTime+delta*0.3,1)
						xzvel=xzvel*(1-noYvelTime)
					elseif Yvel>0 then
						pos=pos+v3_010*Yvel*delta
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsJump()
						noYvelTime=0
					else
						pos=pos+v3_010*Yvel*delta
						cfr=cfAdd(cfGet(cfr,"Rotation"),pos)
						camcf=cfAdd(camrot,pos+v3_0150+camcfLV*cammag)*camoffset
						insSet(fhrp,"CFrame",cfr)
						cframes[rootpart]=insGet(fhrp,"CFrame")
						insSet(cam,"CFrame",camcf)
						lerpsFall()
						noYvelTime=0
					end
				end
			end
			
			if not raycastresult then
				insSet(fhrp,"Velocity",v3_0)
			end

			refreshjointsI(rootpart)
			tclear(refreshedjoints)

			local idlerv=v3(sin((sine-0.0375)*16),sin(sine*16),sin((sine+0.075)*16))
			local idleoff=idlerv*0.0015

			local claimpos=insGet(primarypart,"Position")
			local claimposY=v3Get(claimpos,"Y")
			for i,v in next,cframes do
				local part=i.p
				if part then
					if insGet(part,"ReceiveAge")==0 then
						local placeholder=i.v
						if novoid and (cfGet(v,"Y")<novoid) then
							v=cfAdd(v,v3_010*(novoid-cfGet(v,"Y")))
						end
						local lastpos=i.l
						local vel=(cfGet(v,"Position")-lastpos)/delta
						local mag=v3Get(vel,"Magnitude")
						if mag<0.15 then
							if placeholder then
								insSet(placeholder,"Parent",nil)
							end
							i.l=cfGet(v,"Position")
							v=cfAdd(v,idleoff)
						elseif mag>speedlimit then
							if placeholder then
								insSet(placeholder,"CFrame",v)
								insSet(placeholder,"Parent",fc)
							end
							vel=v3Get(vel,"Unit")*speedlimit
							local newpos=lastpos+vel*delta
							v=cfAdd(cfGet(v,"Rotation"),newpos)
							i.l=newpos
						elseif placeholder then
							insSet(placeholder,"Parent",nil)
							i.l=cfGet(v,"Position")
						end
						local claimtime=i.c
						if claimtime then
							if sine-claimtime<retVelTime then
								local Ydiff=cfGet(v,"Y")-claimposY
								local velY=25.01
								local fallingTime=0
								while (Ydiff>0) or (velY>0) do
									fallingTime=fallingTime+0.025
									if fallingTime>0.6 then
										break
									end
									velY=velY-velYdelta
									Ydiff=Ydiff+(velY*0.025)
								end
								insSet(part,"AssemblyLinearVelocity",(claimpos-cfGet(v,"Position"))*v3_101/fallingTime+v3_net)
							else
								insSet(part,"AssemblyLinearVelocity",getNetlessVelocity(vel*noYvelTime+xzvel))
							end
						else
							i.c=sine
							insSet(part,"AssemblyLinearVelocity",getNetlessVelocity(vel*noYvelTime+xzvel))
						end
						insSet(part,"CFrame",v)
						insSet(part,"AssemblyAngularVelocity",idlerv)
					else
						i.c=nil
						i.l=insGet(part,"Position")
						local placeholder=i.v
						if placeholder then
							insSet(placeholder,"CFrame",v)
							insSet(placeholder,"Parent",fc)
						end
					end
				else
					local placeholder=i.v
					if placeholder then
						insSet(placeholder,"CFrame",v)
						insSet(placeholder,"Parent",fc)
					end
				end
				setsimrad()
			end
			
			setWalkSpeed(fct.hn.WalkSpeed)
			setJumpPower(fct.hn.JumpPower)
			if not setcharacter then
				Move(fct.hn,insGet(FindFirstChildOfClass(c,"Humanoid"),"MoveDirection"))
			end
			
			for _,v in next,joints do
				if rigtype15 then
					if v.Name=="RootJoint" then
						v.C0=fct.hrp.CFrame:ToObjectSpace(fct.t.CFrame)
						v.C1=cf(0,-hipheight,0)
					elseif v.Name=="Neck" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.h.CFrame)
						v.C1=cf()
					elseif v.Name=="Right Shoulder" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.ra.CFrame)
						v.C1=cf()
					elseif v.Name=="Left Shoulder" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.la.CFrame)
						v.C1=cf()
					elseif v.Name=="Right Hip" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.rl.CFrame)
						v.C1=cf()
					elseif v.Name=="Left Hip" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.ll.CFrame)
						v.C1=cf()
					end
				else
					if v.Name=="RootJoint" then
						v.C0=fct.hrp.CFrame:ToObjectSpace(fct.t.CFrame)
						v.C1=cf(0,-hipheight,0)
					elseif v.Name=="Neck" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.h.CFrame)
						v.C1=cf()
					elseif v.Name=="Right Shoulder" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.ra.CFrame)
						v.C1=cf()
					elseif v.Name=="Left Shoulder" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.la.CFrame)
						v.C1=cf()
					elseif v.Name=="Right Hip" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.rl.CFrame)
						v.C1=cf()
					elseif v.Name=="Left Hip" then
						v.C0=fct.t.CFrame:ToObjectSpace(fct.ll.CFrame)
						v.C1=cf()
					end
				end
			end
			if settings then
				settings().Physics.AreOwnersShown = shownownerships
				settings().Physics.AreRegionsShown = shownregions
				settings().Physics.AllowSleep = false
			end
		end

		sine=osclock()
		lastsine=sine
		con=Connect(heartbeat,mainFunction)
		mainFunction()
		
		return {
			options=options,
			cframes=cframes,
			parts=R6parts,
			joints=joints,
			flingtable=flingtable,
			gp=gp,
			timegp=timegp,
			insSet=insSet,
			insGet=insGet,
			cfMul=cfMul,
			deadcharacter=getRealCharacter,
			character=fc,
			mouse=mouse,
			fling=predictionfling,
			predictionfling=predictionfling,
			refreshjoints=refreshjoints,
			raycastlegs=raycastlegs,
			velbycfrvec=velbycfrvec,
			velchgbycfrvec=velchgbycfrvec,
			velYchg=velYchg,
			addmode=addmode,
			getPart=getPart,
			getPartFromMesh=getPartFromMesh,
			getAccWeldFromMesh=getAccWeldFromMesh,
			getJoint=getJoint,
			getPartJoint=getPartJoint,
			rotToMouse=rotToMouse,
			glitchJoint=glitchJoint,
			glitchJoints=glitchJoints,
			setWalkSpeed=setWalkSpeed,
			setJumpPower=setJumpPower,
			setGravity=setGravity,
			setCfr=setCfr,
			lerpCfr=lerpCfr,
			setCamOffset=setCamOffset,
			setScale=setScale,
			keepGui=keepGui,
			disconnectOnDead=disconnectOnDead,
			getVel=getVel,
			getCamCF=getCamCF,
			isOnAir=isOnAir,
			isFirstPerson=isFirstPerson,
			isTarget=isTarget
		}
	end
	return {start=startreanimation,stop=stopreanimation}
end
